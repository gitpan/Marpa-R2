\input texinfo @c -*-texinfo-*- 
@c %**start of header 
@setfilename api.info 
@settitle libmarpa @value{VERSION}
@c %**end of header 
@include version.texi
@copying 
This manual is for libmarpa @value{VERSION}. 
Copyright @copyright{} 2012 Jeffrey Kegler.
@quotation 
Permission is granted to copy, distribute and/or modify this document 
under the terms of the GNU Free Documentation License, Version 1.2 or 
any later version published by the Free Software Foundation;
@end quotation 
@end copying 
@finalout
@titlepage 
@title libmarpa
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Jeffrey Kegler
@c The following two commands 
@c start the copyright page. 
@page 
@vskip 0pt plus 1filll 
@insertcopying

Published @value{UPDATED} by Jeffrey Kegler
@end titlepage 
@c So the toc is printed at the start. 
@contents 
@ifnottex 
@node Top 
@top title 

This manual is for libmarpa, version @value{VERSION}. 

@end ifnottex 
@menu 
* How to read this document:: How to read this document
* About libmarpa:: About libmarpa
* Concepts:: libmarpa Concepts
* Version checking:: Checking the libmarpa version
* Grammars:: Grammars
* Events:: Events
* Recognizers:: Recognizers
* Bocage:: Bocage objects
* Order:: Order objects
* Tree:: Parse Trees
* Value:: Value objects
* Error handling:: Error handling
@end menu 

@node How to read this document
@chapter How to read this document

@menu 
* What is this document::What is this document?
* Prerequisites::Prerequisites
* Which chapters to read first::Which chapters to read first
* Parsing theory::Parsing theory
@end menu 

@node What is this document
@section What is this document?

This document is intended as a reference manual
for a complex low-level tool.
The reader might compare it to the GNU C Language
manual, which makes no attempt to teach much of
the technical knowledge required to appreciate its
contents or, for that matter,
even the C language itself.

@node Prerequisites
@section Prerequisites

This document is very far from self-contained.
It assumes the following:
@itemize
@item
The reader knows the C programming language.
@item
The reader
has read the documents for one of libmarpa's upper layers.
@item
The reader
is at least slightly familiar with Glib,
and has the @cite{Glib Reference  Manual} available.
In particular, the reader should know the type system
described in its "Basic Types" section.
@item
The reader knows some parsing theory.
@xref{Parsing theory}.
@end itemize

@node Which chapters to read first
@section Which chapters to read first

Early chapters of this document lay out concepts,
while later chapters describe libmarpa's object in
detail,
or deal with optional topics.
This document expects the reader will read its
"concept" chapters first, and in the order of
presentation.
With those as background, the reader should
then be able to read the rest of the material
in the order,
and to the extent,
of his interest.

@node Parsing theory
@section Parsing theory

This document also assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
If you were given a Marpa sequence rule,
could you rewrite it in BNF?
@item
Would you know whether your rewrite was
left- or right-recursive?
@item
Could you change it from one to the other?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list either off the top of his head,
or after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader who has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About libmarpa
@chapter About libmarpa
This is the reference manual for libmarpa.
Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering and evaluation of the parse
trees.

However, it is very low-level.
libmarpa, for example, has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate libmarpa's integer IDs to strings or other
values as required.

libmarpa also does NOT implement most of the semantics.
libmarpa does have an evaluator, but it does NOT
manipulate the stack directly.
Instead, libmarpa,
based on its traversal of the parse tree,
passes step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved
involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

While libmarpa passes instruction for stack manipulation,
it does not actually maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
libmarpa does not know that the operation
is an addition.
It will tell the application that rule number R
is to be applied to the arguments at stack locations
N and N+, and that the result is to placed in
stack location N.

In this system,
The application keeps track of the semantics for all
rules, so it looks up rule R and determines that it
is an addition.
The application can do this by using R as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule R.
libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations N and N+1 in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
libmarpa has told the application that the result
belongs at location N in the stack,
so the application writes 752 to location N.

Since libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers; or objects which may be any
or all of these and more.

This technique
hides libmarpa's grammar rewrites from the application,
and is actually quite efficient.
libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily,
and for these libmarpa the series of steps
suggest by libmarpa will be significantly faster than the standard 
stack evaluation algorithm in the textbooks.

To make it clear,
I am under no illusion that libmarpa's evaluator will be found
satisfactory even to most application programmers.
I certainly avoid using it directly.
It is intended to be used via an upper layer,
one which does know about semantics.

But, by isolating libmarpa from semantics, libmarpa avoids
imposing any arbitrary restrictions on the semantics used
with the Marpa algorithm.
To see the advantage suppose, as I expect will often be the case,
libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, libmarpa would have to deal in C callback,
which wrapper the callbacks in the higher level language.
This is complex to code and inefficient,
but that is not its worst aspect.
The worst aspect happens when there is a programming error.
This error will occur inside libmarpa,
and inside code about which libmarpa can make no assumptions.

If all semantics are implemented in the application,
the application is in a much better position to prevent errors,
to catch them at runtime or
failing all else,
to successfully debug the logic.

@node Concepts
@chapter libmarpa Concepts

@menu 
* Token values:: Token values
@end menu 

@node Token values
@section Token values

Token values are @code{gpointer}'s.
(In Glib, @code{gpointer}'s is @code{typedef}'d to @code{void *}.)
libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.

In fact,
the author recommends that token values always
be integers.
While token values are simply passed into libmarpa and back out,
but the user may need to check their validity.
This could be the case, for example, during development.
When the values are integers, validity checking is easy
to do safely.
When they are pointers,
validity checking without risking an abend is hard
or impossible.
Integers can be used to access any kind of data
using an array,
so that the higher levels can translate integers back
and forth into whatever the application requires.

Integers of types @code{gint}, @code{guint}, @code{gsize}
can be portably converted into @code{gpointer}'s using
Glib macros.
These are described in the "Type Conversion Macros" section
of the Glib Reference Manual ( @code{GINT_TO_POINTER}, etc.)

Since the author strongly recommends using integers,
why are token values always @code{gpointer}'s?
Pointers can portably be converted into integers
and back,
while the reverse is not true.
In some circumstances an
application programmer may find minor
efficiencies from the direct use of pointers,
and may believe these outweigh the safety
issues advanced by this author.
It is in the UNIX and Perl traditions to
avoid imposing choices on the user.

@node Version checking
@chapter Checking the libmarpa version
@cindex version checking

@deftypefun const char* marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro} @
    )

Checks that the Marpa library in use is compatible with the
given version. Generally you would pass in the constants
@code{MARPA_MAJOR_VERSION},
@code{MARPA_MINOR_VERSION},
@code{MARPA_MICRO_VERSION}
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of libmarpa the application or module was compiled
against.

Once we are beyond alpha releases,
compatibility will be defined by three things:
first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Currently libmarpa is undergoing rapid development,
and backward compatibility is not maintained.
This will be the case as long as libmarpa stays
alpha.

While libmarpa is still alpha, much stricter compatibility
will be enforced.
While libmarpa is alpha 
the major, minor and micro numbers must match exactly.
Technically, the post-alpha rules can be said to apply
because the very strict alpha rules imply them.

Return value: %NULL if the Marpa library is compatible with the
  given version, or a string describing the version mismatch.
  The returned string is owned by Marpa and must not be modified
  or freed.

@end deftypefun

@node Grammars
@chapter Grammars
@cindex grammars

@menu 
* Grammar constructor:: Creating a new grammar
* Grammar reference counting:: Tracking the reference count of the grammar
* Symbols:: Symbols
* Terminals:: Terminal symbols
* Grammar precomputation::Precomputing the Grammar
* Rules:: Rules
* Symbol internals:: Methods that deal with symbol internals
* Grammar internals:: Methods that deal with grammar internals
@end menu 

@node Grammar constructor
@section Creating a new grammar
@cindex grammar constructor

@deftypefun Marpa_Grammar marpa_g_new ( @
    guint @var{required_major}, @
    guint @var{required_minor}, @
    guint @var{required_micro})

Creates a new grammar time object.
The returned grammar object not be precomputed,
and will have no symbols and rules.
Its reference count will be 1.

After a marpa_g_new call, the next step is
usually the addition of rules and symbols
in preparation for grammar precomputation.

The expected major, minor and micro version
numbers must be passed as arguments,
While libmarpa is alpha,
any mismatch with the actual version will
cause a failure.

Return value: On success, the grammar object.
On failure, @code{NULL}.

@end deftypefun

@node Grammar reference counting
@section Tracking the reference count of the grammar
@cindex grammar destructor
@cindex grammar reference
@cindex grammar reference count

Grammar time objects are created by
@code{marpa_g_new} with a reference count of 1.
@code{marpa_r_new} and @code{marpa_g_ref} increment the
reference count by 1.
@code{marpa_g_unref} decrements the reference count by 1.

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
@end deftypefun

Decreases the reference count by 1,
destroying @var{g} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

Return value: None

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})
@end deftypefun

Increases the reference count.

Return value:
On success, the grammar object it was called with;
@code{NULL} on failure.

@node Symbols
@section Symbols

@deftypefun Marpa_Symbol_ID marpa_g_symbol_new (Marpa_Grammar @var{g})

Creates a new symbol.
Symbols are initialized to non-terminals.

Return value: On success, the ID of the new symbol; 
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{id})

Sets the start symbol of grammar @var{g} to symbol @code{id}.
To be precomputed, a grammar must have a start symbol.

Return value: On success, the ID of the new start symbol.
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol (Marpa_Grammar @var{g})

Returns current value of the start symbol of grammar @var{g}.
The value is that of the user's start
symbol, as specified in the @var{marpa_g_start_symbol_set} call,
if there has been one.
Marpa "augments" its grammars,
creating one or two new, internal start symbols.

Return value:
On failure, -2;
-1 if there is no start symbol yet;
otherwise the ID of the new start symbol.

@end deftypefun

@deftypefun gint marpa_g_symbol_count (Marpa_Grammar @var{g})
@end deftypefun

@node Terminals
@section Methods that deal with terminal symbols

@deftypefun gint marpa_g_default_token_value ( @
    Marpa_Grammar @var{g}, @
    gpointer* @var{value_pointer})

For each grammar, there is a default token value, which is passed
on to its recognizers.
@code{marpa_g_default_token_value}
assumes that the caller has made sure that @var{value_pointer} is
a valid location,
and writes the current default token there.

Return value: -2 if there was an error;
    Otherwise a non-negative integer.

@end deftypefun

@deftypefun gint marpa_g_default_token_value_set ( @
    Marpa_Grammar @var{g}, @
    gpointer @var{value})

For each grammar, there is a default token value, which is passed
on to its recognizers.
@code{marpa_g_default_token_value_set} sets this value
to @var{value}.
Marpa will never dereference @var{value},
so that @var{value} does not need to be a valid pointer,
and may be @code{NULL}.

Return value: -2 if there was an error;
    Otherwise a non-negative integer.

@end deftypefun

@deftypefun gint marpa_g_is_lhs_terminal_ok (Marpa_Grammar @var{g})
@deftypefunx gint marpa_g_is_lhs_terminal_ok_set ( @
    Marpa_Grammar @var{g}, @
    gint @var{value})
@end deftypefun

@deftypefun gint marpa_g_symbol_is_terminal ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@deftypefunx gint marpa_g_symbol_is_terminal_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 gint @var{value})
@end deftypefun

@node Grammar precomputation
@section Precomputing the Grammar

@deftypefun gint marpa_g_precompute (Marpa_Grammar @var{g})
@end deftypefun

@deftypefun gint marpa_g_is_precomputed (Marpa_Grammar @var{g})
@end deftypefun

@deftypefun gint marpa_g_has_loop (Marpa_Grammar @var{g})
@end deftypefun

@node Rules
@section Methods that deal with rules

@deftypefun gint marpa_g_rule_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_rule_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs}, @
 Marpa_Symbol_ID *@var{rhs}, @
     gint @var{length})
@end deftypefun

@deftypefun gint marpa_g_sequence_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID @var{rhs_id}, @
     Marpa_Symbol_ID @var{separator_id}, @
    gint @var{min}, @
 gint @var{flags} )
@end deftypefun

@deftypefun gint marpa_g_rule_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
@end deftypefun

@deftypefun gint marpa_g_rule_is_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_virtual_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_used (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_virtual_lhs (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_rule_is_virtual_rhs (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun guint marpa_g_virtual_start (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun guint marpa_g_virtual_end (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_rule_original (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun gint marpa_g_real_symbol_count (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_rule_semantic_equivalent (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_rule_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun

@deftypefun gint marpa_g_rule_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun

@deftypefun gint marpa_g_rule_is_discard_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id}, @
    gint @var{ix})
@end deftypefun

@deftypefun gint marpa_g_rule_whatever_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx gint marpa_g_rule_first_child_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx gint marpa_g_rule_ask_me_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx gint marpa_g_rule_is_ask_me ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})

Usually,
most of the semantics must be implemented by Marpa's
higher layers.
This is called @dfn{"ask me" semantics}.
In two special but common cases, however,
Marpa can implement the semantics internally,
eliminating an evaluation step.
This can be an considerable efficiency.

The two optimizable cases are "whatever semantics
and "first child" semantics.
If a rule has
@dfn{whatever semantics}, that means
that the higher layers
do not care about the value of the rule.
If a rule has
@dfn{first child semantics}, the value of the rule
should be the value of its first child node.
In the current implementation, both of these
can be implemented as stack no-ops.

In the current implementation,
first child semantics is equivalent to whatever semantics.
It is possible that a future implementation will
be unable to implement first child semantics as a stack
no-op.
At that point first child semantics will made equivalent
to "ask me" semantics.

Return value: -2 if there was an error.
  On success, 1 if the resulting semantics after
  the function call is the "ask me" semantics.
  Otherise, 0 otherwise.

@end deftypefun

@node Symbol internals
@section Methods that deal with symbol internals

@deftypefun gint marpa_g_symbol_is_start ( Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})

This return value of this call indicates whether @var{symid}
is the ID of one of Marpa's internal start symbols.
Marpa rewrites its grammars to add
a new start rule
and one or two new, internal, start symbols.
The first start symbol is always non-nullable.
It is the LHS of the new start rule,
and that is its only occurrence in any rule.

The second start symbol is 
a nulling start symbol.
It is only present
if the grammar allows the null parse.
For Marpa, null parses are handled as
a very special case.
The nulling start symbol is used,
but no nulling rule is created,
so that the nulling start symbol is
never on the LHS or RHS of any rule.

Rewriting a grammar to add a new start
is a very standard procedure,
so much so that it has a special
name:
@dfn{augmenting the grammar}.
The rewritten grammar is called
an @dfn{augmented grammar}.

Return value: -2 if the grammar is not precomputed or
    @var{symid} is not valid;
    1 if @var{symid} is a start symbol in the rewritten grammar;
    0 otherwise.

@end deftypefun

@deftypefun gint marpa_g_symbol_lhs_count (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_symbol_lhs (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 gint @var{ix})
@end deftypefun
@deftypefun gint marpa_g_symbol_rhs_count (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_symbol_rhs (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 gint @var{ix})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_counted (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_nullable (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun gint marpa_g_symbol_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_symbol_proper_alias (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_symbol_null_alias (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_symbol_virtual_lhs_rule (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun

@node Grammar internals
@section Methods that deal with grammar internals

The methods in this section are accessors for libmarpa's
AHFA items and states.
Their use requires familiarity with
Marpa's internals, as described in
@cite{Marpa: The Program}.
These methods will not be of interest to most users.

@deftypefun gint marpa_g_AHFA_item_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID marpa_g_AHFA_item_rule (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_item_position (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_AHFA_item_postdot (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_item_sort_key (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_item_count (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_AHFA_Item_ID marpa_g_AHFA_state_item (Marpa_Grammar @var{g}, @
     Marpa_AHFA_State_ID @var{AHFA_state_id}, @
 gint @var{item_ix})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_is_predict (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID marpa_g_AHFA_state_leo_lhs_symbol (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun gint marpa_g_AHFA_state_transitions (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id}, @
    GArray *@var{result})
@end deftypefun
@deftypefun Marpa_AHFA_State_ID marpa_g_AHFA_state_empty_transition (Marpa_Grammar @var{g}, @
     Marpa_AHFA_Item_ID @var{AHFA_item_id})
@end deftypefun

@node Events
@chapter Events

@menu
* Event accessor::Event accessor
* Event codes::Event codes
@end menu

@node Event accessor
@section Accessing events

@deftypefun gint marpa_g_event (Marpa_Grammar @var{g}, @
    Marpa_Event @var{public_event}, @
	       gint @var{ix})
@end deftypefun

@node Event codes
@section Event codes

@deftypevr Macro int MARPA_EVENT_NONE
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EXHAUSTED
Suggested message: "Recognizer is exhausted."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EARLEY_ITEM_THRESHOLD
Suggested message: "Too many Earley items."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_LOOP_RULES
Suggested message: "A rule is part of a infinite loop."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NEW_SYMBOL
Suggested message: "New symbol."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NEW_RULE
Suggested message: "New rule."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_COUNTED_NULLABLE
Suggested message: "Grammar has a counted nullable."
@end deftypevr

@node Recognizers
@chapter Recognizer objects

@menu 
* Recognizer constructor:: Creating a new recognizer
* Recognizer reference counting:: Keeping the reference count of a recognizer
* Recognizer life:: Taking a recognizer through its life cycle
* Recognizer internals:: Meddling with the recognizer internals
@end menu 

@node Recognizer constructor
@section Creating a new recognizer

@deftypefun Marpa_Recognizer marpa_r_new ( Marpa_Grammar @var{g} )
@end deftypefun

@node Recognizer reference counting
@section Keeping the reference count of a recognizer

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
@end deftypefun

@node Recognizer life
@section Taking a recognizer through its life cycle

@deftypefun gint marpa_r_start_input (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_alternative (Marpa_Recognizer r, Marpa_Symbol_ID @var{token_id}, gpointer @var{value}, gint @var{length})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Error_Code marpa_r_error @
    (Marpa_Recognizer @var{r}, @
    const char** @var{p_error_string})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{set_id})

Given the ID (ordinal) of an Earley set,
return the earleme.
In the default, token-stream model, ID and earleme
are the same, but this is not the case in other input
models.
If the ordinal is out of bounds, this function
returns -1, which can be treated as a soft failure.
On other problems, it returns -2.
@end deftypefun

@deftypefun guint marpa_r_current_earleme (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_item_warning_threshold (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_item_warning_threshold_set (Marpa_Recognizer @var{r}, @
    gint @var{threshold})
@end deftypefun

@deftypefun guint marpa_r_furthest_earleme (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_terminals_expected (Marpa_Recognizer @var{r}, GArray* @var{result})
@end deftypefun

@deftypefun gint marpa_r_is_use_leo (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_is_use_leo_set ( Marpa_Recognizer @var{r}, @
    gint @var{value})
@end deftypefun

@deftypefun gint marpa_r_is_exhausted (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun gint marpa_r_event (Marpa_Recognizer @var{r}, @
    Marpa_Event @var{public_event}, @
    gint @var{ix})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_trace_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_latest_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun


@node Recognizer internals
@section Meddling with the recognizer internals

@deftypefun gint marpa_r_earley_set_size (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earley_set_trace (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_earley_item_trace (Marpa_Recognizer r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_earley_item_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_leo_predecessor_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_leo_base_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_base_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_expansion_ahfa (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_postdot_symbol_trace (Marpa_Recognizer r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_postdot_item_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_source_predecessor_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_token (Marpa_Recognizer r, gpointer *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_leo_transition_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_source_middle (Marpa_Recognizer @var{r})
@end deftypefun

@node Bocage
@chapter Bocage objects

@menu
* Bocage internals::Bocage internals
@end menu

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Rule_ID @var{rule_id}, @
    Marpa_Earley_Set_ID @var{ordinal_arg})
@end deftypefun

@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
@end deftypefun

@node Bocage internals
@section Internals

@deftypefun gint marpa_b_and_node_count ( @
    Marpa_Bocage @var{b})
@end deftypefun

@deftypefun gint marpa_b_and_node_parent ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun gint marpa_b_and_node_predecessor ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun gint marpa_b_and_node_cause ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun gint marpa_b_and_node_symbol ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_b_and_node_token ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id}, @
    gpointer* @var{value_p})

Returns the data for the token of the and-node.
The symbol id is the return value,
and the token value is placed
in the location pointed
to by @var{value_p}, if that is non-null.
If @var{and_node_id} is not the ID of an and-node
whose cause is a token,
returns -1,
without changing @var{value_p}.
On hard failure, returns -2 without changing
@var{value_p}.

There is no function to simply return the token value --
because of the need to indicate errors, it is just as
easy to return the symbol ID as well.
@end deftypefun

@deftypefun Marpa_Or_Node_ID marpa_b_top_or_node ( @
    Marpa_Bocage @var{b})

Return the ID of the top or-node.
@end deftypefun

@deftypefun gint marpa_b_or_node_set ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})

Return the ordinal of the current (final) Earley set of
the or-node.
@end deftypefun

@deftypefun gint marpa_b_or_node_origin ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_rule ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_position ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_first_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_last_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun gint marpa_b_or_node_and_count ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@node Order
@chapter Order objects

@deftypefun Marpa_Order marpa_o_new ( @
    Marpa_Bocage @var{b})
@end deftypefun

@deftypefun void marpa_o_unref ( @
    Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Order marpa_o_ref ( @
    Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Grammar marpa_o_g ( @
    Marpa_Order @var{o})
@end deftypefun

@deftypefun gint marpa_o_and_order_set ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    Marpa_And_Node_ID* @var{and_node_ids}, @
    gint @var{length})
@end deftypefun

@deftypefun Marpa_And_Node_ID marpa_o_and_order_get ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    gint @var{ix})
@end deftypefun

@node Tree
@chapter Tree time objects

Within Marpa,
when it makes sense in context,
"tree" means a parse tree.
Marpa's parse trees are also bocage iterators.

@menu
* Tree internals::Internals
@end menu

@deftypefun Marpa_Tree marpa_t_new (Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Grammar marpa_t_g (Marpa_Tree @var{o})

This function returns the grammar of the tree.
It never returns an error.
The grammar is always set when the tree is initialized,
and is never changed while the tree exists.
Fatal state is not reported,
because it is kept in the grammar,
so that
either we can return the grammar in spite of
its fatal state,
or the problem is so severe than no
errors can be properly reported.

@end deftypefun

@deftypefun Marpa_Tree marpa_t_ref (Marpa_Tree @var{t})
@end deftypefun

@deftypefun void marpa_t_unref (Marpa_Tree @var{t})
@end deftypefun

@deftypefun gint marpa_t_next ( @
	Marpa_Tree @var{t})
@end deftypefun

@deftypefun gint marpa_t_parse_count ( @
	Marpa_Tree @var{t})
@end deftypefun

@node Tree internals
@section Internals

In Marpa, a nook is any node of a parse tree.
The usual term is "node",
but within Marpa,
the word "node" is already heavily overloaded.
So what most texts call "tree nodes" are here
called "nooks".
"Nook" can be thought of as a pun on both
"node" and "fork".

@deftypefun gint marpa_t_size ( @
	Marpa_Tree @var{t})

Return the size of the parse tree.
This is the number of nooks in its stack.
If there is a serioius error,
or if the tree is uninitialized, return -2.
If the tree is exhausted, return -1.
@end deftypefun

@deftypefun Marpa_Or_Node_ID marpa_t_nook_or_node ( @
    Marpa_Tree @var{t}, @
    Marpa_Nook_ID @var{nook_id})

Return the ID of the or-node for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_choice ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the current choice for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_parent ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the parent nook's ID for @var{nook_id}.
As with the other nook trace functions,
-1 is returned if @var{nook_id} is not the ID of
a nook on the stack,
but -1 can also be a valid value.
If that's an issue, the @var{nook_id} needs
to be checked with one of the trace functions
where -1 is never a valid value ---
for example, @code{marpa_t_nook_or_node}.
@end deftypefun 
@deftypefun gint marpa_t_nook_cause_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the cause-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_predecessor_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the predecessor-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_is_cause ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-cause bit for @var{nook_id}.
@end deftypefun

@deftypefun gint marpa_t_nook_is_predecessor ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-predecessor bit for @var{nook_id}.
@end deftypefun

@node Value
@chapter Value objects

@deftypefun Marpa_Value marpa_v_new ( @
    Marpa_Tree @var{t})
@end deftypefun

@deftypefun void marpa_v_unref (Marpa_Value @var{v})
@end deftypefun

@deftypefun Marpa_Value marpa_v_ref (Marpa_Value @var{v})
@end deftypefun

@deftypefun Marpa_Grammar marpa_v_g (Marpa_Value @var{v})

Returns the grammar of the value.
It never returns an error.
The grammar is always set when the value is initialized,
and is never changed while the value exists.
Fatal state is not reported,
because it is kept in the grammar,
so that
either we can return the grammar in spite of
its fatal state,
or the problem is so severe than no
errors can be properly reported.

@end deftypefun

@deftypefun Marpa_Nook_ID marpa_v_step ( @
    Marpa_Value @var{v}, @
    Marpa_Step* @var{step})
@end deftypefun

@deftypefun gint marpa_v_trace ( @
    Marpa_Value @var{v}, @
    gint @var{flag})
@end deftypefun

@deftypefun Marpa_Nook_ID marpa_v_nook ( @
    Marpa_Value @var{v})
@end deftypefun

@node Error handling
@chapter Error handling

@section Soft and hard errors

Soft errors are errors which may be a result of normal processing.
Soft errors often do not disrupt the flow of processing,
and applications typically do not treat soft errors
as fatal errors.
When a soft error is an interruption of normal processing,
the disruption is usually recoverable.

Hard errors are errors which are never the result of
normal processing.
They almost always disrupt the flow of processing.
Recovery from a hard error is usually not possible,
and an application will usually treat a hard error
as a fatal error.

The difference between hard and soft errors can
depend, to a certain extent,
on the application.
libmarpa has its own idea of what is a hard
and soft error but,
whenever possible,
it does not enforce this on the application.
An application is also free to treat a soft
error as a hard error.
And libmarpa makes
every attempt to allow an application to
reinterpret a hard error as a soft error.

@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
@end deftypefun

@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@section Error Codes

@deftypevr Macro int MARPA_ERR_NONE
No error condition since the last time the
error code was reset or,
if there was no reset,
since grammar initialization.
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
All sorts of questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
The "development" errors is for use during
libmarpa's development,
while it is not yet clear how precisely
to classify every error condition.
The error string is a
short 7-bit ASCII error string
which describes the error.
Classifying an error as "development"
is a temporary measure,
taken until the error can be more
precisely defined and classed.
Suggested message: "Development error, see string."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
libmarpa allows a maximum number of earley
items per Earley set.
This error code indicates that limit was
exceeded.
Note that this limit is different from
the optional earley item
warning threshold, which can be set
by the application.
Exceeding the warning threshold causes
a libmarpa event, which the application
is free to treat as a hard or soft error.
Suggested message: "Maximum number of earley items exceeded."

Most likely, memory will run out for
other reasons long before this error can
occur.
The maximum earley item count for the
purposes of this error code
is over a billion.
As a contrast, a reasonable setting for the
warning threshold,
even when exceeding the threshold is
treated as a fatal error,
will usually be well under 1000.
If this error code ever does occur,
it is almost certainly both a hard and a 
fatal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
Internal errors are errors which
"should not happen".
They could result when the calling program
overwrites libmarpa's internal data.
They may also indicate a bug in libmarpa.
An internal error will usually be a hard error.
Suggested message: "Internal error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_LHS_IS_TERMINAL
By default,
and unlike most parsing algorithms,
libmarpa allow LHS terminals
-- symbols on the LHS side of a rule,
but which may also be terminals.
This behavior is configurable,
and if
the LHS terminals flag for a grammar is unset,
LHS terminals become illegal,
and cause this error.
Suggested message: "There is a LHS terminal in a grammar which has disallowed them."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULL_RULE_UNMARKED_TERMINALS
Marpa allows all symbols to be terminals, even those on the LHS,
and this is the default.
But when there is an null rule in the grammar,
having lots of terminals is an efficiency hit.
For that reason, if a grammar has a null rule,
libmarpa requires the application to explictly
indicate which symbols are terminals,
and will not accept the default.

An application is still able to have as many terminals
as it wants,
including terminals on the LHS of rules.
The only requirement is the the user explicitly
set those symbols which are terminals.
Terminals may be explicitly marked on a per-symbol
basis.
The application can
also prevent this error by
unsetting the LHS terminals flag for a grammar.
Suggested message: "A grammar with null rules must mark its terminals."
@end deftypevr

@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYMBOL
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNKNOWN
The cause of the error could not be determined.
This usually indicates a problem in the error handling
logic itself.
This will usually be a hard error.
Suggested message: "Unknown error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORDER_FROZEN
The Marpa order object has been frozen.
Multiple trees can share a Marpa order object,
but that order object is @dfn{frozen} after the first tree
is created from it.
If a Marpa order object is @dfn{frozen}, it cannot be
changed.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
@end deftypevr

@bye
