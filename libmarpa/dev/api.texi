\input texinfo @c -*-texinfo-*- 
@c %**start of header
@setfilename api.info 
@settitle Libmarpa @value{VERSION}
@c %**end of header 
@include version.texi
@copying 
This manual is for Libmarpa @value{VERSION}. 
Copyright @copyright{} 2012 Jeffrey Kegler.
@quotation 
Permission is granted to copy, distribute and/or modify this document 
under the terms of the GNU Free Documentation License, Version 1.2 or 
any later version published by the Free Software Foundation;
@end quotation 
@end copying 
@finalout
@titlepage 
@title Libmarpa
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Jeffrey Kegler
@c The following two commands 
@c start the copyright page. 
@page 
@vskip 0pt plus 1filll 
@insertcopying

Published @value{UPDATED} by Jeffrey Kegler
@end titlepage 
@c So the toc is printed at the start. 
@contents 
@ifnottex 
@node Top, How to read this document, (dir), (dir)
@top Libmarpa: The Marpa low-level library

This manual is for Libmarpa, version @value{VERSION}. 

@end ifnottex 
@menu
* How to read this document::   
* About Libmarpa::              What is Libmarpa?
* Time objects::                
* The architecture of Marpa::   
* Threads::                     
* Numbered objects::            
* Rule concepts::               
* Symbol concepts::             
* Terminals concepts::          
* Semantics::                   
* Version checking::            Checking the Libmarpa version.
* Grammars::                    Grammar time objects
* Events::                      Libmarpa Events
* Recognizers::                 Recognizers.
* Bocage::                      Bocage objects.
* Order::                       Order objects.
* Tree::                        Parse Trees.
* Value::                       Value objects.
* Error handling::              
* Design considerations::       
* Things To Do::                

@detailmenu
 --- The Detailed Node Listing ---

How to read this document

* What is this document::       What is this document?
* Prerequisites::               Prerequisites.
* Which chapters to read first::  Which chapters to read first.
* Parsing theory::              Parsing theory.

Time objects

* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  

The architecture of Marpa

* Architecture - Grammar::      
* Recognition versus parsing::  

Grammars

* Precomputation::              

Threads

* Grammars not shared between threads::  
* C89 and thread-safety::       

Terminals

* LHS Terminals::               

Semantics

* Token values::                

Grammars

* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals::                   Terminal symbols.
* Rules::                       
* Sequences::                   
* Grammar precomputation::      Precomputing the Grammar.
* Symbol internals::            Methods that deal with symbol internals.
* Rule internals::              
* Grammar internals::           Methods that deal with grammar internals.

Events

* Event accessor::              Event accessor.
* Event codes::                 Event codes.

Recognizer objects

* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life::             Taking a recognizer through its life cycle.
* Recognizer internals::        Meddling with the recognizer internals.

Bocage objects

* Bocage reference counting::   
* Bocage internals::            Bocage internals.

Orderings

* Ordering constructor::        
* Ordering reference counting::  
* Ordering internals::          

Tree iterators

* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
* Tree internals::              Internals.

Value objects

* About the valuator::          
* Valuator constructor::        
* Valuator access macros::      
* Valuator reference counting::  
* Valuator stepping::           
* Valuator tracing::            

Design considerations

* Why so many time objects::    
* Design of numbered objects::  

@end detailmenu
@end menu

@node How to read this document, About Libmarpa, Top, Top
@chapter How to read this document

@menu
* What is this document::       What is this document?
* Prerequisites::               Prerequisites.
* Which chapters to read first::  Which chapters to read first.
* Parsing theory::              Parsing theory.
@end menu 

@node What is this document, Prerequisites, How to read this document, How to read this document
@section What is this document?

This document is intended as a reference manual
for a complex low-level tool.
The reader might compare it to the GNU C Language
manual,
which makes no attempt to teach
the C language itself,
much less all the technical knowledge required
to fully understand its contents.

@node Prerequisites, Which chapters to read first, What is this document, How to read this document
@section Prerequisites

This document is very far from self-contained.
It assumes the following:
@itemize
@item
The reader knows the C programming language.
@item
The reader
has read the documents for one of Libmarpa's upper layers.
@item
The reader knows some parsing theory.
@xref{Parsing theory}.
@end itemize

@node Which chapters to read first, Parsing theory, Prerequisites, How to read this document
@section Which chapters to read first

Early chapters of this document lay out concepts,
while later chapters describe Libmarpa's object in
detail,
or deal with optional topics.
This document expects the reader will read its
"concept" chapters first, and in the order of
presentation.
With those as background, the reader should
then be able to read the rest of the material
in the order,
and to the extent,
of his interest.

@node Parsing theory,  , Which chapters to read first, How to read this document
@section Parsing theory

This document also assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
Take a Marpa sequence rule at random.
What does it look like when rewritten in BNF?
(Marpa sequences are implemented as left-recursions.)
@item
What does the sequence look like when rewritten
in BNF as a right-recursion?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader who has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About Libmarpa, Time objects, How to read this document, Top
@chapter About Libmarpa
This is the reference manual for Libmarpa.
Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering and evaluation of the parse
trees.

However, it is very low-level.
Libmarpa, for example, has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate Libmarpa's integer IDs to strings or other
values as required.

Libmarpa also does NOT implement most of the semantics.
Libmarpa does have an evaluator, but it does NOT
manipulate the stack directly.
Instead, Libmarpa,
based on its traversal of the parse tree,
passes optimized step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved
involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

If all semantics are implemented in the application,
the application is in a much better position to prevent errors,
to catch them at runtime or
failing all else,
to successfully debug the logic.

@node Time objects, The architecture of Marpa, About Libmarpa, Top
@chapter Time objects

Libmarpa's most important objects are time objects.
Time objects are so called for two related reasons.
First, they relate to a "time" in the progress of a parse.
Second, each time object has a lifetime and is reference counted.

Libmarpa's major objects are called "time" objects instead
of phase objects,
because phases are exclusive and non-simultaneous
-- when one phase ends, another begins.
Time objects are often in use simultaneously.
In our lives, work and play are times.
Infancy, adolescent and adulthood are phases.

The time objects are, in sequence:
@itemize 
@item Grammars.
@item Recognizers.
@item Bocages.
@item Orderings.
@item Trees.
@item Valuators.
@end itemize 

@menu
* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  
@end menu

@node The sequence of time objects, Base grammars, Time objects, Time objects
@section The sequence of time objects

While time objects do not correspond to phases,
they do have a well-defined sequence.
Except for grammars,
all time objects are created from another time
object.
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.

@node Base grammars, The lifetime of time objects, The sequence of time objects, Time objects
@section Every time object has a base grammar

When one time object is used to create a second
time object,
the first time object is the @dfn{parent object}
and the second time object is the @dfn{child object}.
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.

Grammars have no parent object.
Every other time object has exactly one parent object.
Valuation objects have no child objects.
All other time objects can have any number of children,
from zero up to a number determined by the memory limits
or the architecture.

Every time object has a @dfn{base grammar}.
A grammar object is its own base grammar.
The base grammar of a recognizer is the grammar
that it was created with.
The base grammar of any other time object is the base
grammar of its parent object.
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.

@node The lifetime of time objects,  , Base grammars, Time objects
@section The lifetime of time objects

Time objects are reference-counted.
Every time object is created with a reference count of 1.
Whenever one time object is created from another,
the parent time object has its reference count incremented
by 1.

Time objects do not have explicit destructors.
Every time object has a method which decrements its
reference count by 1.
When the reference count of a time object reaches
0, that time object is destroyed.

In ordinary circumstances, all an application has to
do is keep in mind that it "owns" the time objects
it has created,
and that it must call a method
to "unreference" that object when it is finished.

In some applications, multiple parts of it
may need to share ownership of an object.
For such situations,
every time object has a method to increment
the reference count.

@node The architecture of Marpa, Threads, Time objects, Top
@chapter The architecture of Marpa

@menu
* Architecture - Grammar::      
* Recognition versus parsing::  
@end menu

@node Architecture - Grammar, Recognition versus parsing, The architecture of Marpa, The architecture of Marpa
@section Grammars

As per parsing theory,
before an input can be parsed,
a grammar must be defined.
Traditionally,
a grammar consists of a set of terminal symbols,
a set of non-terminal symbols,
a set of rules,
and a distinguished start symbol.

@menu
* Precomputation::              
@end menu

@node Precomputation,  , Architecture - Grammar, Architecture - Grammar
@subsection Precomputation

Before a recognizer can be created from a grammar,
it must be precomputed.
Internally, precomputation is what the term
suggests --
the memoization of a large number
of facts about the grammar to allow
the recognizer to proceed more efficiently.
Marpa makes aggressive use of grammar precomputation.

Precomputation "freezes" a grammar.
New symbols, rules and sequences cannot be added
to a precomputed grammar
are disallowed,
as are most other changes.

@node Recognition versus parsing,  , Architecture - Grammar, The architecture of Marpa
@section Recognition versus parsing

Even in the academic literature,
parsing is used in many senses,

Determining whether a string matches a grammar is called
@dfn{recognition}.
Finding the structure of the recognized string according
to the grammar is
@dfn{parsing} in a very strict sense of the term.
Strictly speaking,
Earley's algorithm was a recognizer,
and not a parser.
Marpa contains both a recognizer
and a parser in the strict sense.
Marpa's recognizer is implemented by its recognizer time objects.
Marpa's parser in the strict sense
is implemented by its bocage class and the classes
which follow the bocage in the time object sequence.

@node Threads, Numbered objects, The architecture of Marpa, Top
@chapter Threads

Libmarpa is C89-compliant
and uses no global data.
This means that it is thread-safe,
with restrictions.

@menu
* Grammars not shared between threads::  
* C89 and thread-safety::       
@end menu

@node Grammars not shared between threads, C89 and thread-safety, Threads, Threads
@section Grammars cannot be shared between threads
While Libmarpa can be used safely across
multiple threads,
a Libmarpa grammar cannot be.
Further, a Libmarpa time object can
only be used safely in the same thread
as its base grammar.
This is because all
time objects with the same base grammar share data
from that base grammar.

To work around this limitation,
the same grammar definition can be
used to a Libmarpa grammar
time object in each thread.
If there is sufficient interest, future versions of
Libmarpa could allow cloning of grammars and other
time objects.

@node C89 and thread-safety,  , Grammars not shared between threads, Threads
@section C89 and thread-safety
Libmarpa calls only routines defined in the C89 standard,
and in most modern implementations these are thread-safe.
But the C89 standard does not require thread-safety,
and even the most modern environments allow the user
to turn thread safety off.
Libmarpa's thread-safety relies on an environment
that quarantees the thread-safe of C89 function calls.

@node Numbered objects, Rule concepts, Threads, Top
@chapter Numbered objects

In addition to its major, "time" objects, Libmarpa also has
numbered objects
Examples of numbered objects are rules and symbols.
Numbered objects do not have lifetimes of their own.
Every numbered object belongs to a timed object,
and is destroyed with it.

@node Rule concepts, Symbol concepts, Numbered objects, Top
@chapter Rules

Rules are numbered objects.
At every point, where the rule count in @var{N},
there are rules numbered from 0 to @var{N}@minus{}1.
A rule is either external or internal.
An external rule is one intended to be visible
to the application.
An internal rule is one that the application
should only take note of, to the extent
that for the purpose of tracking rule numbers.
The application should not attempt to
alter internal rules.
The rules are never changed after precomputation.

Several methods associated with libmarpa's grammar
objects create rules.
This is documented with the method.
It is an implication of libmarpa's rule numbering
scheme,
that if the rule count was @var{X} before a method call,
and was @var{Y} after that call,
then the method call created @var{Y}@minus{}@var{X} rules,
numbered from @var{X} to @var{Y}@minus{}1.
At most one of these rules will be external,
and which rule that is will be indicated to
the application,
as described in the description of that method call.

@node Symbol concepts, Terminals concepts, Rule concepts, Top
@chapter Symbols

Symbols are numbered objects.
At every point, where the symbol count in @var{N},
there are symbols numbered from 0 to @var{N}@minus{}1.
A symbol is either external or internal.
An external symbol is one intended to be visible
to the application.
An internal symbol is one that the application
should only take note of, to the extent
that for the purpose of tracking symbol numbers.
The application should not attempt to
alter internal symbols.
The symbols are never changed after precomputation.

Several methods associated with libmarpa's grammar
objects create symbols.
This is documented with the method.
It is an implication of libmarpa's symbol numbering
scheme,
that if the symbol count was @var{X} before a method call,
and was @var{Y} after that call,
then the method call created @var{Y}@minus{}@var{X} symbols,
numbered from @var{X} to @var{Y}@minus{}1.
At most one of these symbols will be external,
and which symbol that is will be indicated to
the application,
as described in the description of that method call.

@node Terminals concepts, Semantics, Symbol concepts, Top
@chapter Terminals

A terminal symbol is symbol which
may appear in the input.
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals.
Marpa's grammars differ from the traditional ones
in that there is no necessary distinction between
terminals and non-terminals.
In Marpa,
a terminal may be the start symbol,
and may appear on the LHS of a rule.
However,
since terminals can never be zero length,
it is a logical contradiction for a nulling
symbol to also be a terminal
and Marpa does not allow it.

@menu
* LHS Terminals::               
@end menu

@node LHS Terminals,  , Terminals concepts, Terminals concepts
@section Uses for LHS terminals

Marpa's idea
in losing the sharp division between terminals
and non-terminals is that the distinction,
while helpful for proving theorems,
is not essential in practice.
If LHS symbols 
appear in the input they, in effect,
"short circuiting" the rules in which they occur.
This may
be helpful in debugging, or have other applications.

However,
it also can be useful, 
for checking input validity as well as for efficiency,
to follow tradition and distingush
non-terminals from terminals.
For this reason,
the traditional behavior is the default
in Marpa.

@node Semantics, Version checking, Terminals concepts, Top
@chapter Semantics

@menu
* Token values::                
@end menu

@node Token values,  , Semantics, Semantics
@section Token values

Token values are @code{int}'s.
Libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.
Integers are used as token values instead of
pointers because their validity can be safely checked.
It is hard or impossible
to check the validity of pointers
without risking an abend.

Integers can be used to access any kind of data
using an array,
so that the higher levels can translate integers back
and forth into whatever the application requires.
A future version of Libmarpa may allow
pointer values,
for those circumstances in which some
programmers find that the minor
efficiencies from the direct use of pointers,
outweigh the safety
issues advanced by this author.

@node Version checking, Grammars, Semantics, Top
@chapter Checking the Libmarpa version
@cindex version checking

@deftypefun Marpa_Error_Code marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro} @
    )

Checks that the Marpa library in use is compatible with the
given version. Generally you would pass in the constants
@code{MARPA_MAJOR_VERSION},
@code{MARPA_MINOR_VERSION},
@code{MARPA_MICRO_VERSION}
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of Libmarpa the application or module was compiled
against.

Once we are beyond alpha releases,
compatibility will be defined by three things:
first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Currently Libmarpa is undergoing rapid development,
and backward compatibility is not maintained.
This will be the case as long as Libmarpa stays
alpha.

While Libmarpa is still alpha, much stricter compatibility
will be enforced.
While Libmarpa is alpha 
the major, minor and micro numbers must match exactly.
Technically, the post-alpha rules can be said to apply
because the very strict alpha rules imply them.

Return value: @code{MARPA_ERR_NONE} if the Marpa library is compatible with the
  requested version.  If the library is not compatible,
  one of @code{MARPA_ERR_MAJOR_VERSION_MISMATCH},
  @code{MARPA_ERR_MINOR_VERSION_MISMATCH} or
  @code{MARPA_ERR_MICRO_VERSION_MISMATCH}
  is returned, depending on the nature of the mismatch.

@end deftypefun

@node Grammars, Events, Version checking, Top
@chapter Grammars
@cindex grammars

@menu
* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals::                   Terminal symbols.
* Rules::                       
* Sequences::                   
* Grammar precomputation::      Precomputing the Grammar.
* Symbol internals::            Methods that deal with symbol internals.
* Rule internals::              
* Grammar internals::           Methods that deal with grammar internals.
@end menu 

@node Grammar constructor, Grammar reference counting, Grammars, Grammars
@section Creating a new grammar
@cindex grammar constructor

@deftypefun Marpa_Grammar marpa_g_new ( @
    unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro})

Creates a new grammar time object.
The returned grammar object not be precomputed,
and will have no symbols and rules.
Its reference count will be 1.

After a marpa_g_new call, the next step is
usually the addition of rules and symbols
in preparation for grammar precomputation.

The expected major, minor and micro version
numbers must be passed as arguments,
While Libmarpa is alpha,
any mismatch with the actual version will
cause a failure.

Return value: On success, the grammar object.
On failure, @code{NULL}.

@end deftypefun

@node Grammar reference counting, Symbols, Grammar constructor, Grammars
@section Tracking the reference count of the grammar
@cindex grammar destructor
@cindex grammar reference
@cindex grammar reference count

Grammar time objects are created by
@code{marpa_g_new} with a reference count of 1.
@code{marpa_r_new} and @code{marpa_g_ref} increment the
reference count by 1.
@code{marpa_g_unref} decrements the reference count by 1.

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
@end deftypefun

Decreases the reference count by 1,
destroying @var{g} once the reference count reaches
zero.
Libmarpa time objects have no explicit destructor.
They are destroyed by reducing their reference count to zero.

Return value: None

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})
@end deftypefun

Increases the reference count.

Return value:
On success, the grammar object it was called with;
@code{NULL} on failure.

@node Symbols, Terminals, Grammar reference counting, Grammars
@section Symbols

@deftypefun Marpa_Symbol_ID marpa_g_symbol_new (Marpa_Grammar @var{g})

Creates a new symbol.

Return value: On success, the ID of the new symbol; 
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{id})

Sets the start symbol of grammar @var{g} to symbol @code{id}.
To be precomputed, a grammar must have a start symbol.

Return value: On success, the ID of the new start symbol.
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol (Marpa_Grammar @var{g})

Returns current value of the start symbol of grammar @var{g}.
The value is that of the user's start
symbol, as specified in the @var{marpa_g_start_symbol_set} call,
if there has been one.
Marpa "augments" its grammars,
creating one or two new, internal start symbols.

Return value:
On failure, -2;
-1 if there is no start symbol yet;
otherwise the ID of the new start symbol.
@end deftypefun

@deftypefun int marpa_g_symbol_count (Marpa_Grammar @var{g})
Return value:
On success, the symbol count of the grammar.
On failure, -2.
@end deftypefun

@node Terminals, Rules, Symbols, Grammars
@section Methods for terminal symbols

@deftypefun int marpa_g_symbol_is_terminal ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
Return value: On success, 1 if @var{symid} is a terminal symbol, 0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_terminal_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 int @var{value})
This function flags symbol @var{symid} as a terminal if
@var{value} is 1,
or flags it as a non-terminal if @var{value} is 0.
This setting overrides the default.
An attempt to flag a nulling symbol
as a terminal is a fatal error,
but this is not necesssarily detected before precomputation.

Return value: On success, 1 if @var{symid} is a terminal symbol after the
call, 0 otherwise.
-2 if symbol @var{symid} is internal;
if @var{value} is not 0 or 1;
if the grammar @var{g} is precomputed;
or on some other failure.
@end deftypefun

@deftypefun int marpa_g_symbol_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{accessible} if it can be reached from the start symbol.
This is not known until the grammar is precomputed.

Return value: On success, 1 if accessible, 0 if not.  If the grammar
is not precomputed, or on failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{productive} if it can produce a string of terminals.
All nullable symbols are considered productive.
This is not known until the grammar is precomputed.

Return value: On success, 1 if productive, 0 if not.  If the grammar
is not precomputed, or on failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_internal (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{internal} if it is one of those created
by libmarpa for its own internal uses.
Libmarpa controls the behavior of internal symbols,
and so that many operations are invalid for them.
For example, the user cannot set them to be terminals,
and they may be explicitly included in the LHS or RHS
of rules and sequences.

Return value: On success, 1 if symbol is internal, 0 if not.
If the symbol ID is not valid, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{nulling} if it always produces the empty string.
This is not determined until the grammar is precomputed.

Return value: On success, 1 if symbol is nulling, 0 if not.
If the grammar is not precomputed, or on failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_nullable ( @
  Marpa_Grammar g, Marpa_Symbol_ID symid)
A symbol is @dfn{nullable} if it sometimes produces the empty string.
A nulling symbol is always a nullable symbol,
but not all nullable symbols are nulling symbols.
This is not determined until the grammar is precomputed.

Return value: On success, 1 if symbol is nullable, 0 if not.
If the grammar is not precomputed, or on failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_ask_me_when_null_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id}, @
    int value)
@deftypefunx int marpa_g_symbol_is_ask_me_when_null ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id})

In Marpa,
most of the semantics is usually be implemented by the
higher layers.
This is called @dfn{"ask me" semantics}.
The "ask me when null"
calls deal with the handling of semantics
in case when the symbol is nulling.
For proper nullables,
the "Ask me when null" setting is relevant
only in cases where the symbol is nulled.

Marpa's default is to assume that the
value of nulled symbols will be ignored,
and to let that value be arbitrary.
"Arbitrary" here means it may not be relied
and may change from instance to instance.
Marpa optimizes for cases where symbols
have arbitrary values.

Return value: -2 if there was an error.
  On success, 1 if the resulting semantics after
  the function call is the "ask me" semantics.
  Otherise, 0 otherwise.

@end deftypefun

@node Rules, Sequences, Terminals, Grammars
@section Rules

@deftypefun int marpa_g_rule_count (Marpa_Grammar @var{g})
Return value: On success, the current number of rules in grammar @var{g}.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_g_rule_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs}, @
 Marpa_Symbol_ID *@var{rhs}, @
     int @var{length})
Creates a new external rule in grammar @var{g}.
The LHS symbol is @var{lhs},
and there are @var{length} symbols on the RHS,
which is pointed to by @var{rhs}.

An attempt to add a duplicate rule is a hard failure.
A rule is considered a duplicate if it has the same
LHS symbol,
and the same RHS symbols in the same order.

On success,
this call creates a new external rule,
whose ID is the return value.
No symbols or internal rules will be created.

Return value:  On success, the ID of new external rule.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value: On success, the LHS symbol of the rule.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
The length of a rule is the number of symbols on its RHS.

Return value: On success, the rule length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id}, @
    int @var{ix})
The position in the rule, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
rule, it is a soft failure.
This can be used in loops, to avoid having to determine
the rule's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the rules RHS.
If @var{ix} is greater than or equal to the length of
the rule, -1.
On other failures, -2.
@end deftypefun

@deftypefun int marpa_g_rule_whatever_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx int marpa_g_rule_first_child_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx int marpa_g_rule_ask_me_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@deftypefunx int marpa_g_rule_is_ask_me ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})

Usually,
most of the semantics must be implemented by Marpa's
higher layers.
This is called @dfn{"ask me" semantics}.
In two special but common cases, however,
Marpa can implement the semantics internally,
eliminating an evaluation step.
This can be an considerable efficiency.

The two optimizable cases are "whatever semantics
and "first child" semantics.
If a rule has
@dfn{whatever semantics}, that means
that the higher layers
do not care about the value of the rule.
If a rule has
@dfn{first child semantics}, the value of the rule
should be the value of its first child node.
In the current implementation, both of these
can be implemented as stack no-ops.

In the current implementation,
first child semantics is equivalent to whatever semantics.
It is possible that a future implementation will
be unable to implement first child semantics as a stack
no-op.
At that point first child semantics will made equivalent
to "ask me" semantics.

Return value: -2 if there was an error.
  On success, 1 if the resulting semantics after
  the function call is the "ask me" semantics.
  Otherise, 0 otherwise.

@end deftypefun

@deftypefun int marpa_g_rule_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{accessible} if it can be reached from the start symbol.
This is not known until the grammar is precomputed.
A rule is accessible if and only if its LHS symbol is accessible.
The start rule is always an accessible rule.

Return value: On success, 1 if accessible, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{productive} if it can be produce a string of terminals.
including the empty string.
This is not known until the grammar is precomputed.
An rule is productive if and only if all the symbols on
its RHS are productive.
An empty rule is considered productive, vacuously.

Return value: On success, 1 if productive, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
A rule is a loop rule if it non-trivially
produces the string of length one
which consists only of its LHS symbol.
``Non-trivially'' means the zero-step derivation does not count -- the
derivation must have at least one step.

The presence of a loop rule makes a grammar infinitely ambiguous,
and applications will typically want to treat them as fatal errors.
But nothing forces an application to do this,
and Marpa will successfully parse and evaluate grammars with
loop rules.

Return value: On success, 1 if this is a loop rule, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@node Sequences, Grammar precomputation, Rules, Grammars
@section Sequences

@deftypefun Marpa_Rule_ID marpa_g_sequence_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID @var{rhs_id}, @
     Marpa_Symbol_ID @var{separator_id}, @
    int @var{min}, @
 int @var{flags} )
Adds a new sequence rule to grammar @var{g}.
Internally, Libmarpa translates sequences into BNF
rules, but it also optimizes their evaluation.
In practice this speedup can be considerable --
25% or more.

The sequence is @var{lhs_id},
and the item to be repeated in the sequence is @var{rhs_id}.
The sequence must be repeated at least @var{min} times,
where @var{min} is 0 or 1.
If @var{separator_id} is non-negative,
it is a separator symbol.

If @code{flags & MARPA_PROPER_SEPARATION} is non-zero,
separation is ``proper'', that is,
a trailing separator is not allowed.
The term @dfn{proper} is based on the idea that
properly-speaking, separators should actually separate items.

The sequence RHS, or item,
is restricted to a single symbol,
but almost arbitrary semantics can be expressed by having
@var{rhs_id} be the LHS of another rule.
A restrictions is that @var{rhs_id},
cannot be a nullable symbol.

If @var{separator_id} is a symbol, it also cannot
be a nullable symbol.
Nullables on the RHS of sequences are restricted
because they lead to highly ambiguous grammars.
Such grammars are allowed by Libmarpa, but
sequence optimizations would not work
for in the presence of nullables.
Also it is not clearly clear what
an application intends
when it asks for a sequence of items, some of which
may be null.
In such a case,
the user's intent is most clearly expressed
directly in BNF.

On success,
this call creates a new external rule,
whose ID is its return value.
It also creates zero or more internal rules,
and zero or more internal symbols.

Return value:  On success, the ID of the external rule.
If the rule duplicates another rule,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_sequence ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:  1 if |rule_id| is a sequence rule,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_counted (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{counted}
if it appears on the RHS of a sequence rule.
The separator symbol of a sequence rule is also considered
to be a counted symbol.

Return value: On success, 1 if the symbol is counted, 0 if not.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_proper_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:
Returns 1 if
the proper separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On hard failure, returns -2.
@end deftypefun

@node Grammar precomputation, Symbol internals, Sequences, Grammars
@section Precomputing the Grammar

@deftypefun int marpa_g_precompute (Marpa_Grammar @var{g})
This function precomputes the grammar.
In the process it may create one or more internal symbols,
and one or more internal rules.

In the process, precomputation creates events which
the user can access.
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether precomputation fails or succeeds.
Applications which fail must call @code{marpa_g_event}
if they want to determine if any events occurred.
Since the reason for failure to precompute is often
detailed in the events, failed applications will often
be at least as interested in the events as those
which succeeded.

Each @code{MARPA_EVENT_LOOP_RULES} event is a rule
which is part of an cycle (infinite loop) in the grammar.
Cycles 
are useless in current (and currently foreseen)
practice.
Cycles make a grammar infinitely ambiguous
and their presence makes processing the grammar less
efficient, sometimes considerably so.
Nonetheless, they are not errors,
although most applications will wish to treat them
as such.

Each @code{MARPA_EVENT_COUNTED_NULLABLE} event is a symbol
which is a nullable on the right hand side of a sequence
rule -- a ``counted'' symbol.
The presence of one or more of these is a fatal error.
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

Each @code{MARPA_EVENT_NULLING_TERMINAL} event is a nulling
symbol which is also flagged as a terminal.
Since terminals cannot be of zero length, this is a logical
impossibility, and
the presence of one or more of these is a fatal error.
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

Precomputation involves freezing 
and then thoroughly checking the grammar,
and it is at this point that many hard errors
are caught and reported.
Counted nullables and nulling terminals have
already been mentioned.
Grammars without rules and those
with invalid start symbols also produce
hard errors.

Return value: On success, the number of events generated.
If the grammar is already precomputed,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_is_precomputed (Marpa_Grammar @var{g})
Return value: On success, 1
if grammar @var{g} is already precomputed,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_has_cycle (Marpa_Grammar @var{g})
This function allows the application to determine if grammar
@var{g} has a cycle.
As mentioned, most applications will want to treat these
as fatal errors.
To determine which rules are in the cycle,
@var{marpa_g_rule_is_loop} can be used.

Return value: On success, 1 if the grammar has a cycle,
0 otherwise.
On failure, -2.
@end deftypefun

@node Symbol internals, Rule internals, Grammar precomputation, Grammars
@section Symbol internals

Internal methods are only for testing and development of libmarpa.
They are listed here (and sometimes describes) for the convenient
of those working on libmarpa's internals.
Applications should not use them,
and should treat them as ``undocumented''.

@deftypefun int _marpa_g_symbol_is_start ( Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})

This return value of this call indicates whether @var{symid}
is the ID of one of Marpa's internal start symbols.
Marpa rewrites its grammars to add
a new start rule
and one or two new, internal, start symbols.
The first start symbol is always non-nullable.
It is the LHS of the new start rule,
and that is its only occurrence in any rule.

The second start symbol is 
a nulling start symbol.
It is only present
if the grammar allows the null parse.
For Marpa, null parses are handled as
a very special case.
The nulling start symbol is used,
but no nulling rule is created,
so that the nulling start symbol is
never on the LHS or RHS of any rule.

Rewriting a grammar to add a new start
is a very standard procedure,
so much so that it has a special
name:
@dfn{augmenting the grammar}.
The rewritten grammar is called
an @dfn{augmented grammar}.

Return value: -2 if the grammar is not precomputed or
    @var{symid} is not valid;
    1 if @var{symid} is a start symbol in the rewritten grammar;
    0 otherwise.

@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_symbol_proper_alias (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_null_alias ( @
  Marpa_Grammar @var{g}, @
  Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_symbol_lhs_xrl ( @
  Marpa_Grammar @var{g}, @
  Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun int _marpa_g_symbol_xrl_offset ( @
  Marpa_Grammar @var{g}, @
  Marpa_Symbol_ID @var{symid} )
@end deftypefun

@node Rule internals, Grammar internals, Symbol internals, Grammars
@section Rule internals

@deftypefun int marpa_g_rule_is_keep_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
This function does nothing but return an undocumented flag.
At some point,
I may optimize cases where separators are discarded,
in which case this flag will be used.
I may also remove this call entirely.
Return value:
Returns 1 if
the keep separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On hard failure, returns -2.
@end deftypefun

Internal methods are only for testing and development of libmarpa.
They are listed here (and sometimes describes) for the convenient
of those working on libmarpa's internals.
Applications should not use them,
and should treat them as ``undocumented''.

@deftypefun Marpa_Rule_ID _marpa_g_irl_co_rule ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_irl_count ( @
  Marpa_Grammar @var{g})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
Return value: On success, the LHS symbol of the IRL.
On failure, -2.
@end deftypefun

@deftypefun int _marpa_g_irl_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
The length of a IRL is the number of symbols on its RHS.

Return value: On success, the IRL length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id}, @
    int @var{ix})
The position in the IRL, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
IRL, it is a soft failure.
This can be used in loops, to avoid having to determine
the IRL's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the IRL's RHS.
If @var{ix} is greater than or equal to the length of
the IRL, -1.
On other failures, -2.
@end deftypefun
@deftypefun int _marpa_g_rule_is_used (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_lhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_rhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun unsigned int _marpa_g_virtual_start (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun unsigned int _marpa_g_virtual_end (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xrl (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_real_symbol_count (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_irl_semantic_equivalent (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun

@node Grammar internals,  , Rule internals, Grammars
@section Methods that deal with grammar internals

Internal methods are only for testing and development of libmarpa.
They are listed here (and sometimes describes) for the convenient
of those working on libmarpa's internals.
Applications should not use them,
and should treat them as ``undocumented''.

The methods in this section are accessors for Libmarpa's
AHFA items and states.
Their use requires familiarity with
Marpa's internals, as described in
@cite{Marpa: The Program}.

@deftypefun int _marpa_g_AHFA_item_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_AHFA_item_irl (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_position (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_item_postdot (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_sort_key (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_item_count (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_AHFA_Item_ID _marpa_g_AHFA_state_item (Marpa_Grammar @var{g}, @
     Marpa_AHFA_State_ID @var{AHFA_state_id}, @
 int @var{item_ix})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_is_predict (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_state_leo_lhs_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_transitions ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id}, @
    int *@var{buffer}, @
    int @var{buffer_size} @
    )
@end deftypefun
@deftypefun Marpa_AHFA_State_ID _marpa_g_AHFA_state_empty_transition ( @
    Marpa_Grammar @var{g}, @
     Marpa_AHFA_Item_ID @var{AHFA_item_id})
@end deftypefun

@node Events, Recognizers, Grammars, Top
@chapter Events

@menu
* Event accessor::              Event accessor.
* Event codes::                 Event codes.
@end menu

@node Event accessor, Event codes, Events, Events
@section Accessing events

@deftypefun int marpa_g_event (Marpa_Grammar @var{g}, @
    Marpa_Event @var{public_event}, @
	       int @var{ix})
@end deftypefun

@node Event codes,  , Event accessor, Events
@section Event codes

@deftypevr Macro int MARPA_EVENT_NONE
Suggested message: "No event."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EXHAUSTED
Suggested message: "Recognizer is exhausted."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EARLEY_ITEM_THRESHOLD
Suggested message: "Too many Earley items."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_LOOP_RULES
A rule is part of a cycle.
Cycles are pathological cases of recursions,
in which the same symbol string derives itself
a potentially infinite number of times.
Nonetheless, Marpa parses in the presence of these,
and it is up to the application to treat these
as fatal errors,
something most of them will wish to do.
The value of the event is the count of loop rules.
Suggested message: "A rule is part of a infinite loop."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_COUNTED_NULLABLE
A nullable is either the separator
for, or the right hand side of a sequence.
The value of the event is the ID of the symbol.
Suggested message: "Grammar has a counted nullable."
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NULLING_TERMINAL
A nulling symbol is also a terminal.
The value of the event is the ID of the symbol.
Suggested message: "Grammar has a nulling terminal."
@end deftypevr

@node Recognizers, Bocage, Events, Top
@chapter Recognizer objects

@menu
* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life::             Taking a recognizer through its life cycle.
* Recognizer internals::        Meddling with the recognizer internals.
@end menu 

@node Recognizer constructor, Recognizer reference counting, Recognizers, Recognizers
@section Creating a new recognizer

@deftypefun Marpa_Recognizer marpa_r_new ( Marpa_Grammar @var{g} )
@end deftypefun

@node Recognizer reference counting, Recognizer life, Recognizer constructor, Recognizers
@section Keeping the reference count of a recognizer

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
@end deftypefun

@node Recognizer life, Recognizer internals, Recognizer reference counting, Recognizers
@section Taking a recognizer through its life cycle

@deftypefun int marpa_r_start_input (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_alternative (Marpa_Recognizer r, @
    Marpa_Symbol_ID @var{token_id}, @
    int @var{value}, @
    int @var{length})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Error_Code marpa_r_error @
    (Marpa_Recognizer @var{r}, @
    const char** @var{p_error_string})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{set_id})

Given the ID (ordinal) of an Earley set,
return the earleme.
In the default, token-stream model, ID and earleme
are the same, but this is not the case in other input
models.
If the ordinal is out of bounds, this function
returns -1, which can be treated as a soft failure.
On other problems, it returns -2.
@end deftypefun

@deftypefun unsigned int marpa_r_current_earleme (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_earley_item_warning_threshold (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_earley_item_warning_threshold_set (Marpa_Recognizer @var{r}, @
    int @var{threshold})
@end deftypefun

@deftypefun unsigned int marpa_r_furthest_earleme (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_terminals_expected ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID* @var{buffer})
@end deftypefun

@deftypefun int marpa_r_is_use_leo (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_is_use_leo_set ( Marpa_Recognizer @var{r}, @
    int @var{value})
@end deftypefun

@deftypefun int marpa_r_is_exhausted (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_event (Marpa_Recognizer @var{r}, @
    Marpa_Event @var{public_event}, @
    int @var{ix})
@end deftypefun

@node Recognizer internals,  , Recognizer life, Recognizers
@section Meddling with the recognizer internals

@deftypefun Marpa_Earley_Set_ID marpa_r_trace_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_latest_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int marpa_r_earley_set_size (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earley_set_trace (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_earley_item_trace (Marpa_Recognizer r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_earley_item_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_leo_predecessor_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_leo_base_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_base_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_expansion_ahfa (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_postdot_symbol_trace (Marpa_Recognizer r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_postdot_item_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_source_predecessor_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_token (Marpa_Recognizer r, int *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_leo_transition_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_source_middle (Marpa_Recognizer @var{r})
@end deftypefun

@node Bocage, Order, Recognizers, Top
@chapter Bocage objects

@menu
* Bocage reference counting::   
* Bocage internals::            Bocage internals.
@end menu

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{ordinal_arg})
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
@end deftypefun

@node Bocage reference counting, Bocage internals, Bocage, Bocage
@section  Reference counting
@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
@end deftypefun

@node Bocage internals,  , Bocage reference counting, Bocage
@section Internals

@deftypefun int _marpa_b_and_node_count ( @
    Marpa_Bocage @var{b})
@end deftypefun

@deftypefun int _marpa_b_and_node_parent ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun int _marpa_b_and_node_predecessor ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun int _marpa_b_and_node_cause ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun int _marpa_b_and_node_symbol ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_b_and_node_token ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id}, @
    int* @var{value_p})

Returns the data for the token of the and-node.
The symbol id is the return value,
and the token value is placed
in the location pointed
to by @var{value_p}, if that is non-null.
If @var{and_node_id} is not the ID of an and-node
whose cause is a token,
returns -1,
without changing @var{value_p}.
On hard failure, returns -2 without changing
@var{value_p}.

There is no function to simply return the token value --
because of the need to indicate errors, it is just as
easy to return the symbol ID as well.
@end deftypefun

@deftypefun Marpa_Or_Node_ID _marpa_b_top_or_node ( @
    Marpa_Bocage @var{b})

Return the ID of the top or-node.
@end deftypefun

@deftypefun int _marpa_b_or_node_set ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})

Return the ordinal of the current (final) Earley set of
the or-node.
@end deftypefun

@deftypefun int _marpa_b_or_node_origin ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun Marpa_IRL_ID _marpa_b_or_node_irl ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun int _marpa_b_or_node_position ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun int _marpa_b_or_node_first_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun int _marpa_b_or_node_last_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@deftypefun int _marpa_b_or_node_and_count ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@node Order, Tree, Bocage, Top
@chapter Orderings

@menu
* Ordering constructor::        
* Ordering reference counting::  
* Ordering internals::          
@end menu

@node Ordering constructor, Ordering reference counting, Order, Order
@section Creating an ordering

@deftypefun Marpa_Order marpa_o_new ( @
    Marpa_Bocage @var{b})
@end deftypefun

@deftypefun Marpa_Grammar marpa_o_g ( @
    Marpa_Order @var{o})
@end deftypefun

@node Ordering reference counting, Ordering internals, Ordering constructor, Order
@section Reference counting

@deftypefun void marpa_o_unref ( @
    Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Order marpa_o_ref ( @
    Marpa_Order @var{o})
@end deftypefun

@node Ordering internals,  , Ordering reference counting, Order
@section Internals

@deftypefun int _marpa_o_and_order_set ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    Marpa_And_Node_ID* @var{and_node_ids}, @
    int @var{length})
@end deftypefun

@deftypefun Marpa_And_Node_ID _marpa_o_and_order_get ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    int @var{ix})
@end deftypefun

@node Tree, Value, Order, Top
@chapter Tree iterators

Within Marpa,
when it makes sense in context,
"tree" means a parse tree.
Marpa's parse trees are also bocage iterators.

@menu
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
* Tree internals::              Internals.
@end menu

@node Tree constructor, Tree reference counting, Tree, Tree
@section Creating a new tree iterator

@deftypefun Marpa_Tree marpa_t_new (Marpa_Order @var{o})
@end deftypefun

@deftypefun Marpa_Grammar marpa_t_g (Marpa_Tree @var{o})

This function returns the grammar of the tree.
It never returns an error.
The grammar is always set when the tree is initialized,
and is never changed while the tree exists.
Fatal state is not reported,
because it is kept in the grammar,
so that
either we can return the grammar in spite of
its fatal state,
or the problem is so severe than no
errors can be properly reported.

@end deftypefun

@node Tree reference counting, Tree iteration, Tree constructor, Tree
@section Reference counting

@deftypefun Marpa_Tree marpa_t_ref (Marpa_Tree @var{t})
@end deftypefun

@deftypefun void marpa_t_unref (Marpa_Tree @var{t})
@end deftypefun

@node Tree iteration, Tree internals, Tree reference counting, Tree
@section Iterating through the trees

@deftypefun int marpa_t_next ( @
	Marpa_Tree @var{t})
@end deftypefun

@deftypefun int marpa_t_parse_count ( @
	Marpa_Tree @var{t})
@end deftypefun

@node Tree internals,  , Tree iteration, Tree
@section Internals

In Marpa, a nook is any node of a parse tree.
The usual term is "node",
but within Marpa,
the word "node" is already heavily overloaded.
So what most texts call "tree nodes" are here
called "nooks".
"Nook" can be thought of as a pun on both
"node" and "fork".

@deftypefun int _marpa_t_size ( @
	Marpa_Tree @var{t})

Return the size of the parse tree.
This is the number of nooks in its stack.
If there is a serioius error,
or if the tree is uninitialized, return -2.
If the tree is exhausted, return -1.
@end deftypefun

@deftypefun Marpa_Or_Node_ID _marpa_t_nook_or_node ( @
    Marpa_Tree @var{t}, @
    Marpa_Nook_ID @var{nook_id})

Return the ID of the or-node for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_choice ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the current choice for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_parent ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the parent nook's ID for @var{nook_id}.
As with the other nook trace functions,
-1 is returned if @var{nook_id} is not the ID of
a nook on the stack,
but -1 can also be a valid value.
If that's an issue, the @var{nook_id} needs
to be checked with one of the trace functions
where -1 is never a valid value ---
for example, @code{_marpa_t_nook_or_node}.
@end deftypefun 

@deftypefun int _marpa_t_nook_cause_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the cause-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_predecessor_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the predecessor-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_cause ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-cause bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_predecessor ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-predecessor bit for @var{nook_id}.
@end deftypefun

@node Value, Error handling, Tree, Top
@chapter Value objects

@menu
* About the valuator::          
* Valuator constructor::        
* Valuator access macros::      
* Valuator reference counting::  
* Valuator stepping::           
* Valuator tracing::            
@end menu

@node About the valuator, Valuator constructor, Value, Value
@section About the valuator
While Libmarpa passes instruction for stack manipulation,
it does not actually maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
Libmarpa does not know that the operation
is an addition.
It will tell the application that rule number R
is to be applied to the arguments at stack locations
N and N+, and that the result is to placed in
stack location N.

In this system,
The application keeps track of the semantics for all
rules, so it looks up rule R and determines that it
is an addition.
The application can do this by using R as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule R.
Libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations N and N+1 in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
Libmarpa has told the application that the result
belongs at location N in the stack,
so the application writes 752 to location N.

Since Libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers; or objects which may be any
or all of these and more.

This technique
hides Libmarpa's grammar rewrites from the application,
and is actually quite efficient.
Libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily,
and for these Libmarpa the series of steps
suggest by Libmarpa will be significantly faster than the standard 
stack evaluation algorithm in the textbooks.

To make it clear,
I am under no illusion that Libmarpa's evaluator will be found
satisfactory even to most application programmers.
I certainly avoid using it directly.
It is intended to be used via an upper layer,
one which does know about semantics.

But, by isolating Libmarpa from semantics, Libmarpa avoids
imposing any arbitrary restrictions on the semantics used
with the Marpa algorithm.
To see the advantage suppose, as I expect will often be the case,
Libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, Libmarpa would have to deal in C callback,
which wrapper the callbacks in the higher level language.
This is complex to code and inefficient,
but that is not its worst aspect.
The worst aspect happens when there is a programming error.
This error will occur inside Libmarpa,
and inside code about which Libmarpa can make no assumptions.

@node Valuator constructor, Valuator access macros, About the valuator, Value
@section Creating a new valuator

@deftypefun Marpa_Value marpa_v_new ( @
    Marpa_Tree @var{t} @
)

@end deftypefun

@deftypefun Marpa_Grammar marpa_v_g ( @
    Marpa_Value @var{v} @
    )

@end deftypefun

@deftypefun void marpa_v_unref ( @
    Marpa_Value @var{v})
@end deftypefun

@deftypefun int marpa_v_symbol_ask_me_when_null_set ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid}, @
    int @var{value} )
@end deftypefun

@deftypefun int marpa_v_symbol_is_ask_me_when_null ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid} )
@end deftypefun

@node Valuator access macros, Valuator reference counting, Valuator constructor, Value
@section Valuator access macros

Accessors which are implemented as macros.

@defmac Marpa_Symbol_ID marpa_v_semantic_token(Marpa_Value @var{v})
@end defmac

@defmac void* marpa_v_token_value(Marpa_Value @var{v})
@end defmac

@defmac Marpa_Rule_ID marpa_v_semantic_rule(Marpa_Value @var{v})
@end defmac

@defmac int marpa_v_arg_0(Marpa_Value @var{v})
@end defmac

@defmac int marpa_v_arg_n(Marpa_Value @var{v})
@end defmac

@node Valuator reference counting, Valuator stepping, Valuator access macros, Value
@section Reference counting

@deftypefun Marpa_Value marpa_v_ref (Marpa_Value @var{v})

Returns the grammar of the value.
It never returns an error.
The grammar is always set when the value is initialized,
and is never changed while the value exists.
Fatal state is not reported,
because it is kept in the grammar,
so that
either we can return the grammar in spite of
its fatal state,
or the problem is so severe than no
errors can be properly reported.

@end deftypefun

@node Valuator stepping, Valuator tracing, Valuator reference counting, Value
@section Stepping through the valuator

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_TRACE
The data for tracing is ready.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_TOKEN
The data for a semantic token is ready.
The token is non-nulling and will have a value.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_NULLING_SYMBOL
The data for a nulling symbol with semantics is ready.
It is up to the application
to provide the value, if one is needed.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_RULE
The data for a semantic rule is ready.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_INACTIVE
The valuator is inactive.
@end deftypevr

@deftypevr Macro Marpa_Value_Type MARPA_VALUE_INTERNAL1
@deftypevrx Macro Marpa_Value_Type MARPA_VALUE_INTERNAL2
These value types are reserved for internal purposes
@end deftypevr

@deftypefun Marpa_Value_Type marpa_v_step ( @
    Marpa_Value @var{v})
@end deftypefun

@node Valuator tracing,  , Valuator stepping, Value
@section Tracing the valuator

@deftypefun int _marpa_v_trace ( @
    Marpa_Value @var{v}, @
    int @var{flag})
@end deftypefun

@deftypefun Marpa_Nook_ID _marpa_v_nook ( @
    Marpa_Value @var{v})
@end deftypefun

@node Error handling, Design considerations, Value, Top
@chapter Error handling

@section Soft and hard errors

Soft errors are errors which may be a result of normal processing.
Soft errors often do not disrupt the flow of processing,
and applications typically do not treat soft errors
as fatal errors.
When a soft error is an interruption of normal processing,
the disruption is usually recoverable.

Hard errors are errors which are never the result of
normal processing.
They almost always disrupt the flow of processing.
Recovery from a hard error is usually not possible,
and an application will usually treat a hard error
as a fatal error.

The difference between hard and soft errors can
depend, to a certain extent,
on the application.
Libmarpa has its own idea of what is a hard
and soft error but,
whenever possible,
it does not enforce this on the application.
An application is also free to treat a soft
error as a hard error.
And Libmarpa makes
every attempt to allow an application to
reinterpret a hard error as a soft error.

@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
@end deftypefun

@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@section Error Codes

@deftypevr Macro int MARPA_ERR_NONE
No error condition since the last time the
error code was reset or,
if there was no reset,
since grammar initialization.
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_AHFA_IX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_AHFA_IX_OOB
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NOT_IN_OR
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDIX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_BAD_SEPARATOR
@end deftypevr
@deftypevr Macro int MARPA_ERR_BOCAGE_ITERATION_EXHAUSTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
All sorts of questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in Libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
The "development" errors is for use during
Libmarpa's development,
while it is not yet clear how precisely
to classify every error condition.
The error string is a
short 7-bit ASCII error string
which describes the error.
Classifying an error as "development"
is a temporary measure,
taken until the error can be more
precisely defined and classed.
Suggested message: "Development error, see string."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_AND_NODE
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
Libmarpa allows a maximum number of earley
items per Earley set.
This error code indicates that limit was
exceeded.
Note that this limit is different from
the optional earley item
warning threshold, which can be set
by the application.
Exceeding the warning threshold causes
a Libmarpa event, which the application
is free to treat as a hard or soft error.
Suggested message: "Maximum number of earley items exceeded."

Most likely, memory will run out for
other reasons long before this error can
occur.
The maximum earley item count for the
purposes of this error code
is over a billion.
As a contrast, a reasonable setting for the
warning threshold,
even when exceeding the threshold is
treated as a fatal error,
will usually be well under 1000.
If this error code ever does occur,
it is almost certainly both a hard and a 
fatal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_ID_INVALID
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
Internal errors are errors which
"should not happen".
They could result when the calling program
overwrites Libmarpa's internal data.
They may also indicate a bug in Libmarpa.
An internal error will usually be a hard error.
Suggested message: "Internal error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL_SYM
In a context
in which an internal symbol is disallowed,
@var{symid} is for an internal symbol.
Suggested message: "Symbol is internal."
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_AHFA_ID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_AIMID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_BOOLEAN
A function was called which takes a boolean argument,
one which must be either 0 or 1,
and that argument has some other value.
Suggested message: "Argument is not boolean."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_ES_ORDINAL
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_IRLID
A method was called with an invalid internal rule ID.
Suggested message: "No IRL with that ID exists."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_RULEID
A method was called with an invalid external rule ID.
Suggested message: "No rule with that ID exists."
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_START_SYM
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_SYMID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_XRLID
A method was called with an invalid external rule ID.
Suggested message: "No rule with that ID exists."
@end deftypevr

@deftypevr Macro int MARPA_ERR_MAJOR_VERSION_MISMATCH
There was a mismatch in the major version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr
@deftypevr Macro int MARPA_ERR_MICRO_VERSION_MISMATCH
There was a mismatch in the micro version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr
@deftypevr Macro int MARPA_ERR_MINOR_VERSION_MISMATCH
There was a mismatch in the minor version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOOKID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_PRECOMPUTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOT_TRACING_COMPLETION_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_LEO_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_TOKEN_LINKS
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_ALIAS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_AND_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_OR_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYM
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_TRACE_ES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_PIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_EIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_SRCL
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULLING_TERMINAL
Marpa does not allow a symbol to be both nulling
and a terminal.
Suggested message: "A symbol is both terminal and nulling."
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_OR_ALREADY_ORDERED
@end deftypevr
@deftypevr Macro int MARPA_ERR_ORDER_FROZEN
The Marpa order object has been frozen.
Multiple trees can share a Marpa order object,
but that order object is @dfn{frozen} after the first tree
is created from it.
If a Marpa order object is @dfn{frozen}, it cannot be
changed.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
@end deftypevr

@deftypevr Macro int MARPA_ERR_PARSE_EXHAUSTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_PARSE_TOO_LONG
@end deftypevr
@deftypevr Macro int MARPA_ERR_PIM_IS_NOT_LIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed."
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_NOT_ACCEPTING_INPUT
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_NOT_STARTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_STARTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_RHS_TOO_LONG
@end deftypevr

@deftypevr Macro int MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE
The LHS of a
sequence rule cannot be the LHS of any other rule,
whether a sequence rule or a BNF rule.
An attempt was made to violate this restriction.
Suggested message: "LHS of sequence rule would not be unique."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_NONE
The link source type is 'none'
in a context where that is not allowed.
Suggested message: "A source type of 'none' is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_TOKEN
The link source type is 'token'
in a context where that is not allowed.
Suggested message: "Token source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_COMPLETION
The link source type is 'completion'
in a context where that is not allowed.
Suggested message: "Completion source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_LEO
The link source type is 'Leo'
in a context where that is not allowed.
Suggested message: "Leo source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_AMBIGUOUS
The link source type is ambiguous
in a context where that is not allowed.
Suggested message: "Ambiguous source type is not allowed here."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_UNKNOWN
The link source type is not known.
Suggested message: "The source type is unknown."
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYMIX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_SYMIX_OOB
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYM_NOT_NULLABLE
In circumstances where a symbol is required to be a nullable
symbol,
it is not.
One such circumstance when the symbol is the
argument of a
@code{marpa_v_symbol_ask_me_when_null_set}
call.
Suggested message: "Symbol not nullable."
@end deftypevr

@deftypevr Macro int MARPA_ERR_TOKEN_IS_NOT_TERMINAL
@end deftypevr
@deftypevr Macro int MARPA_ERR_TOKEN_LENGTH_LE_ZERO
@end deftypevr
@deftypevr Macro int MARPA_ERR_TOKEN_TOO_LONG
@end deftypevr
@deftypevr Macro int MARPA_ERR_TREE_EXHAUSTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_TREE_PAUSED
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNKNOWN
The cause of the error could not be determined.
This usually indicates a problem in the error handling
logic itself.
This will usually be a hard error.
Suggested message: "Unknown error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_VALUATOR_INACTIVE
The valuator is inactive in a context where that
should not be the case.
Suggested message: "Valuator inactive."
@end deftypevr

@node Design considerations, Things To Do, Error handling, Top
@chapter Design considerations

This section details some of the design choices
in Libmarpa.

@menu
* Why so many time objects::    
* Design of numbered objects::  
@end menu

@node Why so many time objects, Design of numbered objects, Design considerations, Design considerations
@section Why so many time objects?

Readers accustomed to other appraoches to parsing,
particular those in fashion at this writing,
may wonder on the number of time objects
in the Marpa architecture.
Several of Marpa's time objects (bocages,
orderings and trees) are required
because Marpa allows,
and offers powerful tools for dealing with,
ambigious grammars.

It may seem, then, that users of unambiguous grammars,
are paying a considerable price in time effiency
for the ability to parse
ambiguous ones.
This is not the case.
In the trivial case, the cost of the orderings
object is a single, very brief, subroutine call.

Bocage objects come at minimal cost,
because the same pass which creates the bocage
also deals with other issues which are of major
significance even for unambiguous parses.
The same pass which creates the bocage
enables Marpa to do both left-
and right-recursion in linear time.

Tree objects come at mininal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal, so that the valuation time object
has very litle to do -- it just steps through the sequence.

But what about the many passes over the data this requires?
Marpa is an aggressively multi-pass algorithm.
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it.
Marpa is @math{O(n)} for LR-regular grammars,
both in theory and in implementation,
because Marpa regularly substitutes
two fast @math{O(n)} passes for a single
@math{O(n log n)} pass.

@node Design of numbered objects,  , Why so many time objects, Design considerations
@section Numbered objects

As the name suggests,
the choice was made to implement
numbered objects and not as
pointers.
Integers can be easily and safely checked for validity,
while pointer cannot.

There are efficiency tradeoffs between pointers and
integers but they are complications and go both ways.
Pointers can be faster, but integers can be used
as indexes into more than one data structure.
Which is actually faster depends on the design.
Integers allow for a more flexible design,
so that once the choice is settled on,
careful programming can make them a win,
possibly a very big one.

The approach taken in Libmarpa was to settle
from the outset,
on integers as the implementation for numbered
objects and optimize on that basis.
In any case, the difference is speed on
modern architectures is
a small price to pay for
safe, portable validity checking.

@node Things To Do,  , Design considerations, Top
@chapter Things to do

@itemize
@item
There should be an interface in the valuator that allows the user to 
determine the start and end earlemes of a token.
@end itemize

@bye
