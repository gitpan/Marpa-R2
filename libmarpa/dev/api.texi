\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename api.info
@settitle Libmarpa @value{VERSION}
@c %**end of header
@include version.texi
@copying
This manual is for Libmarpa @value{VERSION}.
Copyright @copyright{} 2012 Jeffrey Kegler.
@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation;
@end quotation
@end copying
@finalout
@titlepage
@title Libmarpa
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Jeffrey Kegler
@c The following two commands
@c start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying

Published @value{UPDATED} by Jeffrey Kegler
@end titlepage
@c So the toc is printed at the start.
@contents
@ifnottex
@node Top, How to read this document, (dir), (dir)
@top Libmarpa: The Marpa low-level library

This manual is for Libmarpa, version @value{VERSION}.

@end ifnottex
@menu
* How to read this document::   
* About Libmarpa::              What is Libmarpa?
* Architecture::                
* Objects::                     
* Input::                       
* Semantics::                   
* Threads::                     
* Error handling concepts::     
* Introduction to the external interface::  
* Static method::               
* Grammar methods::             
* Recognizer methods::          
* Progress reports::            
* Bocage methods::              
* Ordering methods::            
* Tree methods::                
* Value methods::               
* Events::                      Libmarpa Events
* Error macros and code::       
* Design considerations::       
* Things To Do::                
* Internal Interface::          

@detailmenu
 --- The Detailed Node Listing ---

How to read this document

* Prerequisites::               Prerequisites.
* Parsing theory::              Parsing theory.

Architecture

* Architecture - Grammar::      
* Recognition versus parsing::  

Grammars

* Precomputation::

Recognition versus parsing

* Precomputation::              

Objects

* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  
* Numbered objects::            

Input

* Earlemes::                    
* Terminals::                   
* LHS Terminals::               
* Token values::                

Earlemes

* The traditional model::       
* The earleme variables::       
* The significances of the earleme variables::  
* The initial earleme settings::  
* The standard model of input::  
* Ambiguous input::             
* Variable length tokens::      
* The generalized model::       
* General rules for the earleme variables::  

Terminals

* LHS Terminals::               
* Token values::                

Semantics

* How Libmarpa semantics work::  
* Universe of values::          
* Whatever values::             

Threads

* C89 and thread-safety::       
* Base grammars cannot be shared between threads::  

C89 and thread-safety

* C89 and thread-safety::

Error handling

* Memory allocation failures::  
* Success and failure::         
* Soft and hard failure.::      

Introduction to the external interface

* About the overviews::         
* Return values::               

Grammar methods

* Grammar overview::            
* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals methods::           
* Rules::                       
* Sequences::                   
* Grammar precomputation::      Precomputing the Grammar.
* Grammar events::              

Recognizer methods

* Recognizer overview::         
* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life cycle mutators::  
* Location accessors::          
* Other parse status methods::  
* Recognizer events::           

Bocage methods

* Bocage overview::             
* Bocage reference counting::   

Ordering methods

* Ordering overview::           
* Ordering constructor::        
* Ordering reference counting::  

Tree methods

* Tree overview::               
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              

Value methods

* Value overview::              
* How to use the valuator::     
* Advantages of Libmarpa's valuator::  
* Details of stack manipulation::  
* Valuator constructor::        
* Valuator reference counting::  
* Registering semantics::       
* Stepping through the valuator::  
* Valuator steps by type::      
* Step accessors::              

Details of stack manipulation

* Implications for literal stack manipulation::  
* Implications for non-literal implementations::  

Events

* Event codes::                 Event codes.

Error macros and code

* Methods::                     
* Error Macros::                
* Error Codes::                 

Design considerations

* Why so many time objects::    
* Design of numbered objects::  

Why so many time objects?

* Why ordering objects?::       

Internal Interface

* Symbol internal methods::     
* Rule internals::              
* Grammar internals::           
* Recognizer internals::        
* Bocage internals::            
* Ordering internals::          
* Tree internals::              
* Valuator internals::          

@end detailmenu
@end menu

@node How to read this document, About Libmarpa, Top, Top
@chapter How to read this document

@menu
* Prerequisites::               Prerequisites.
* Parsing theory::              Parsing theory.
@end menu

@node Prerequisites, Parsing theory, How to read this document, How to read this document
@section Prerequisites

This document is very far from self-contained.
It assumes the following:
@itemize
@item
The reader knows the C programming language.
@item
The reader
has read the documents for one of Libmarpa's upper layers.
@item
The reader knows some parsing theory.
@xref{Parsing theory}.
@end itemize

@node Parsing theory,  , Prerequisites, How to read this document
@section Parsing theory

This document assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
Take a Marpa sequence rule at random.
What does it look like when rewritten in BNF?
@item
What does the sequence look like when rewritten
in BNF as a right-recursion?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About Libmarpa, Architecture, How to read this document, Top
@chapter About Libmarpa
Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering, iteration
and evaluation of the parse
trees.

Libmarpa is very low-level.
For example, it has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate Libmarpa's integer ID's to strings or other
values as required.

Libmarpa also does @strong{not} implement most of the semantics.
Libmarpa does have an evaluator (called a ``valuator''),
but it does @strong{not}
manipulate the stack directly.
Instead, Libmarpa,
based on its traversal of the parse tree,
passes optimized step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved
involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

Marpa requires most semantics to be
implemented in the application.
This allows the application total flexibility.
It also puts
the application is in a much better position to prevent errors,
to catch errors at runtime or,
failing all else,
to successfully debug the logic.

@node Architecture, Objects, About Libmarpa, Top
@chapter Architecture

@menu
* Architecture - Grammar::      
* Recognition versus parsing::  
@end menu

@node Architecture - Grammar, Recognition versus parsing, Architecture, Architecture
@section Grammars

As per parsing theory,
before an input can be parsed,
a grammar must be defined.
Traditionally,
a grammar consists of a set of terminal symbols,
a set of non-terminal symbols,
a set of rules,
and a distinguished start symbol.

@menu
* Precomputation::
@end menu

@node Recognition versus parsing,  , Architecture - Grammar, Architecture
@section Recognition versus parsing

Even in the academic literature,
parsing is used in many senses,
Determining whether a string matches a grammar is called
@dfn{recognition}.
Finding the structure of the recognized string according
to the grammar is
@dfn{parsing} in a very strict sense of the term.
Strictly speaking,
Earley's algorithm was a recognizer,
and not a parser.
Marpa contains both a recognizer
and a parser in the strict sense.
Marpa's recognizer is implemented by its recognizer time objects.
Marpa's parser in the strict sense
is implemented by its bocage class and the classes
which follow the bocage in the time object sequence.

@menu
* Precomputation::              
@end menu

@node Precomputation,  , Recognition versus parsing, Recognition versus parsing
@subsection Precomputation

Before a recognizer can be created from a grammar,
it must be precomputed.
Internally, precomputation is what the term
suggests --
the memoization of a large number
of facts about the grammar to allow
the recognizer to proceed more efficiently.
Marpa makes aggressive use of grammar precomputation.

Precomputation ``freezes'' a grammar.
New symbols, rules and sequences cannot be added
to a precomputed grammar
are disallowed,
as are most other changes.

@node Objects, Input, Architecture, Top
@chapter Objects

Libmarpa's most important objects are time objects.
Time objects are so called for two related reasons.
First, they relate to a ``time'' in the progress of a parse.
Second, each time object has a lifetime and is reference counted.

Libmarpa's major objects are called ``time'' objects instead
of phase objects,
because phases are exclusive and non-simultaneous
-- when one phase ends, another begins.
Time objects are often in use simultaneously.
In our lives, work and play are times.
Infancy, adolescent and adulthood are phases.

The time objects are, in sequence:
@itemize
@item Grammars.
@item Recognizers.
@item Bocages.
@item Orderings.
@item Trees.
@item Valuators.
@end itemize

@menu
* The sequence of time objects::  
* Base grammars::               
* The lifetime of time objects::  
* Numbered objects::            
@end menu

@node The sequence of time objects, Base grammars, Objects, Objects
@section The sequence of time objects

While time objects do not correspond to phases,
they do have a well-defined sequence.
Except for grammars,
all time objects are created from another time
object.
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.

@node Base grammars, The lifetime of time objects, The sequence of time objects, Objects
@section Every time object has a base grammar

When one time object is used to create a second
time object,
the first time object is the @dfn{parent object}
and the second time object is the @dfn{child object}.
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.

Grammars have no parent object.
Every other time object has exactly one parent object.
Valuation objects have no child objects.
All other time objects can have any number of children,
from zero up to a number determined by the memory limits
or the architecture.

Every time object has a @dfn{base grammar}.
A grammar object is its own base grammar.
The base grammar of a recognizer is the grammar
that it was created with.
Similarly,
the base grammar of any other time object is the base
grammar of its parent object.
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.

@node The lifetime of time objects, Numbered objects, Base grammars, Objects
@section The lifetime of time objects

Time objects are reference-counted.
Every time object is created with a reference count of 1.
Whenever one time object is created from another,
the parent time object has its reference count incremented
by 1.

Time objects do not have explicit destructors.
Every time object has a method which decrements its
reference count by 1.
When the reference count of a time object reaches
0, that time object is destroyed.

In ordinary circumstances, all an application has to
do is keep in mind that it ``owns'' the time objects
it has created,
and that it must call a method
to ``unreference'' that object when it is finished.

In some applications, multiple parts of it
may need to share ownership of an object.
For such situations,
every time object has a method to increment
the reference count.

@node Numbered objects,  , The lifetime of time objects, Objects
@section Numbered objects

In addition to its major, ``time'' objects, Libmarpa also has
numbered objects.
Numbered objects do not have lifetimes of their own.
Every numbered object belongs to a timed object,
and is destroyed with it.

Rules and symbols are numbered objects.
Tokens values are
another examples of numbered objects.

@node Input, Semantics, Objects, Top
@chapter Input

@menu
* Earlemes::                    
* Terminals::                   
* LHS Terminals::               
* Token values::                
@end menu

@node Earlemes, Terminals, Input, Input
@section Earlemes

@menu
* The traditional model::       
* The earleme variables::       
* The significances of the earleme variables::  
* The initial earleme settings::  
* The standard model of input::  
* Ambiguous input::             
* Variable length tokens::      
* The generalized model::       
* General rules for the earleme variables::  
@end menu

@node The traditional model, The earleme variables, Earlemes, Earlemes
@subsection The traditional model

In traditional Earley parsers, the concept of location is very simple.
Locations are numbered from 0 to @math{n}, where @math{n} is the length of
the input.
Every location has an Earley set, and vice versa.
Location 0 is the start location.
Every location after the start location has exactly one input token
associated with it.

Already some applications
do not fit this traditional input model -- 
natural language processing requires ambiguous tokens,
for example.
Libmarpa's allows a wide variety of alternative input models.

This document assumes that the reader knows the concepts
behind Libmarpa's
alternative input models, either from the documentation
of a higher level interface, such as
@code{Marpa::XS} or
@code{Marpa::R2},
or from Marpa's
@uref{https://github.com/downloads/jeffreykegler/Marpa-theory/recce.pdf, theory document}.

As a reminder,
in Libmarpa a location is called a @dfn{earleme}.
The number of an Earley set is the @dfn{ID of the Earley set},
or its @dfn{ordinal}.
In the traditional model, the ordinal of an Earley set and
its earleme are always exactly the same, but in Libmarpa
they will be different.

@node The earleme variables, The significances of the earleme variables, The traditional model, Earlemes
@subsection The earleme variables

The important earleme variables are the current, the furthest and
the latest earleme.
The @dfn{current earleme} is the earleme that Libmarpa is currently working on.
More specifically, it is the one at which new tokens will @strong{start}.
Since tokens are never zero length, a new token will always end after the
current earleme.
The current earleme is initially earleme 0.
Every call to @code{marpa_r_earleme_complete()} advances the
current earleme by 1.

The @dfn{furthest earleme} is the highest numbered (and therefore ``furthest'')
earleme at which a token ends.
The furthest earleme is initially earleme 0.
With every call to @code{marpa_r_alternative()}, the end of the token
it adds is calculated.
A token ends at earleme @var{end_earleme} = @var{current}+@var{length},
where @var{current} is the current earleme,
and @var{length} is the length of the newly added token.
After a call to @code{marpa_r_alternative()},
the furthest earleme is its value before the call,
or @var{end_earleme}, whichever is greater.

The @dfn{latest earleme} is the earleme of the latest
Earley set.
The @dfn{latest Earley set} is the last Earley set completed.
This is always the highest numbered Earley set.
If there is an Earley set at the current earleme,
it is the latest Earley set and the latest earleme
is equal to the current earleme.
There is never an Earley set after the current earleme.
If there is no Earley set at the current earleme,
the latest Earley set,
which is also the highest numbered Earley set,
is the last one completed.

After every call to the @code{marpa_r_earleme_complete()} method
that adds a token,
the value of the latest earleme is 
same as the value of the current earleme.
After every call to the @code{marpa_r_earleme_complete()} method
that does @strong{not} add a token,
the value of the lastest earleme is unchanged
from its value before the call.

@node The significances of the earleme variables, The initial earleme settings, The earleme variables, Earlemes
@subsection The significances of the earleme variables

The current earleme tracks the advance of the recognizer through the input.
Input tokens always start at the current earleme.
An application can advance past the current earleme,
by calling @code{marpa_r_earleme_complete()}, which
increments the current earleme by 1.
After initialization,
@code{marpa_r_earleme_complete()} is
the only way to manipulate the value of the current earleme.

The furthest earleme tracks how ``far out'' tokens can be found.
In the standard input model, calling 
@code{marpa_r_earleme_complete()} after each
@code{marpa_r_alternative()} call is sufficient to process
all inputs,
and the furthest earleme's value
can be typically be ignored.
In alternative input models, if tokens have lengths greater than
1, calling
@code{marpa_r_earleme_complete()} once after the last token
is read may not be enough to ensure that all tokens have been processed.
To ensure that all tokens have been processed,
an application must advance the current earleme
by calling @code{marpa_r_earleme_complete()},
until the current earleme is equal to the furthest earleme.

The lastest earleme is the earleme of the last Earley set.
Typically, the Earley set ID is the number of greater interest.
It is different from the current earleme if and only if
there is no Earley set at the current earleme.
Once recognition is complete, parsing must take place over
a range of Earley sets.
A different end of parsing can be specified,
but by default, parsing is of the input
from earleme 0 to the latest earleme.

@node The initial earleme settings, The standard model of input, The significances of the earleme variables, Earlemes
@subsection The initial earleme settings

Understanding the
settings of current, latest and furthest earleme is
crucial to working with advanced input models,
and for this reason the next sections will go
through the possibilities carefully.
The presentation will start with the most traditional
and restrictive models.
It will proceed to less restrictive models.

All input models have the same initial values.
Initially the current, latest and furthest earleme
are always earleme 0.

@node The standard model of input, Ambiguous input, The initial earleme settings, Earlemes
@subsection The standard model of input

In the standard model of input,
Calls to @code{marpa_r_alternative()}
and @code{marpa_r_earleme_complete()} are
made in pairs.
There is first exactly one call 
to @code{marpa_r_alternative()}
for a token with length 1.
Following it must be a call
to @code{marpa_r_earleme_complete()}.
For an input of length @var{n}, there will be
exactly @var{n} such paired calls.

In the standard model,
for each call to 
@code{marpa_r_alternative()}
if the current earleme before the call was @var{i},
then after the call
the latest earleme will also be @var{i},
and the furthest earleme will be @var{i}+1.
For each call to
@code{marpa_r_earleme_complete()},
if the current earleme before the call was @var{i},
then after the call
the latest earleme,
the furthest earleme,
and the current earleme
will all be @var{i}+1.

@node Ambiguous input, Variable length tokens, The standard model of input, Earlemes
@subsection Ambiguous input

As a first loosening of the standard model,
we no longer require calls to @code{marpa_r_alternative()}
to be paired with calls to
@code{marpa_r_earleme_complete()}.
Instead,
we allow multiple calls
to @code{marpa_r_alternative()}
before each call to
@code{marpa_r_earleme_complete()}.
We still require that there be at least one call
to @code{marpa_r_alternative()}
before each call to
@code{marpa_r_earleme_complete()},
and we still require that all tokens have 
a length of 1.
In this model, the behavior of the current,
latest and furthest earlemes are exactly
as described for the standard model.

@node Variable length tokens, The generalized model, Ambiguous input, Earlemes
@subsection Variable length tokens

Our next loosening of the restrictions is to allow
variable length tokens.
That is, instead of requiring that all tokens
be of length 1,
we allow tokens to be of length 1 or longer.
This does change the behavior of the earleme variables.

In this new model,
for each call to 
@code{marpa_r_alternative()}
if the current earleme before the call was @var{i},
then after the call
the latest earleme will also be @var{i},
but the furthest earleme will be MAX(@var{f'}, @var{i}+@var{length}),
where @var{f'} is the value of the furthest earleme before the call,
and @var{length} is the length of the token.
That is, the new value of the furthest earleme will
be its previous value,
or the end earleme of the newly added token,
whichever is greater.

For each call to 
@code{marpa_r_earleme_complete()}
if the current earleme before the call was @var{i},
then after the call
the current earleme and latest earleme will both be @var{i+1}.
The furthest earleme is never changed by a call
to @code{marpa_r_earleme_complete()} --
it will have the same value it had before the call.

@node The generalized model, General rules for the earleme variables, Variable length tokens, Earlemes
@subsection The generalized model

To fully generalize the input model,
we now need to remove only one restriction.
We now allow empty earlemes -- earlemes with
no tokens and no Earley set.

An empty earleme 1 can be created by
making a call to @code{marpa_r_earleme_complete()}
when 
no call to @code{marpa_r_alternative()} has been
made for the recognizer.
Later earleme will be empty if two calls
to @code{marpa_r_earleme_complete()}
are made with no intervening call
to @code{marpa_r_alternative()}.

If @code{marpa_r_earleme_complete()} is called
for an empty earleme,
the latest earleme remains unchanged from its
prior value.
This means that, since the current earleme will
change, the latest earleme will be less
than the current earleme.
As always the furthest earleme is unchanged by
the call to @code{marpa_r_earleme_complete()}.

@node General rules for the earleme variables,  , The generalized model, Earlemes
@subsection General rules for the earleme variables

At this point, the most generalized input model has been
introduced.
The following will always be the case,
even in Libmarpa's most generalized input model.

@itemize
@item The current earleme is greater than
or equal to the latest earleme.
@item The furthest earleme is greater than
or equal to the latest earleme.
@item If the parser is not exhausted,
the furthest earleme is always greater than
or equal to the current earleme.
@item In an exhausted parser,
the furthest earleme is always less than
or equal to the current earleme.
@item If the furthest earleme is greater than the current earleme,
the parser is not exhausted.
@item For the furthest earleme to be less than the current earleme,
the parser must be exhausted.
@end itemize

@node Terminals, LHS Terminals, Earlemes, Input
@section Terminals

A terminal symbol is a symbol which
may appear in the input.
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals.
Marpa's grammars differ from the traditional ones
in that there is no necessary distinction between
terminals and non-terminals.
In Marpa,
a terminal may be the start symbol,
and may appear on the LHS of a rule.
However,
since terminals can never be zero length,
it is a logical contradiction for a nulling
symbol to also be a terminal
and Marpa does not allow it.

@menu
* LHS Terminals::               
* Token values::                
@end menu

@node LHS Terminals, Token values, Terminals, Input
@section Uses for LHS terminals

Marpa's idea
in losing the sharp division between terminals
and non-terminals is that the distinction,
while helpful for proving theorems,
is not essential in practice.
If LHS symbols
appear in the input they, in effect,
``short circuiting'' the rules in which they occur.
This may
be helpful in debugging, or have other applications.

However,
it also can be useful,
for checking input validity as well as for efficiency,
to follow tradition and distingush
non-terminals from terminals.
For this reason,
the traditional behavior is the default
in Marpa.

@node Token values,  , LHS Terminals, Input
@section Token values

Token values are @code{int}'s.
Libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.
Integers are used as token values instead of
pointers because their validity can be safely checked.
It is hard or impossible
to check the validity of pointers
without risking an abend.
Integers can be used to access any kind of data
using an array,
so that the higher levels can translate integers back
and forth into whatever the application requires.

@node Semantics, Threads, Input, Top
@chapter Semantics

@menu
* How Libmarpa semantics work::  
* Universe of values::          
* Whatever values::             
@end menu

@node How Libmarpa semantics work, Universe of values, Semantics, Semantics
@section How the Libmarpa semantics work

Libmarpa handling of semantics is unusual.
Most semantics are left up to the application,
but Libmarpa guides them.

Specifically, the application is expected to maintain the evaluation
stack.
Libmarpa's valuator provides instructions on how to handle the stack.
Libmarpa's stack handling instructions
are called ``steps''.
For example, a Libmarpa step might tell the application that the value
of a token needs to go into a certain stack position.
Or a Libmarpa step might tell the application that a rule is to be evaluation.
For rule evalution, Libmarpa will tell the application where the operands
are to be found,
and where the result must go.

@node Universe of values, Whatever values, How Libmarpa semantics work, Semantics
@section The universe of values

The application can react to Libmarpa's stack handling instructions
in any way it sees fit,
but it is expected that it will maintain a physical stack which
can be addressed as an array.

An advantage of leaving the application in control of the stack
is that the applicaion has total control over what the stack values
are.
The set of all possible stack values is the application's
@dfn{universe of values}.
For example, as implemented in Perl,
the universe of values is the Perl scalar-assignables.
In C, they could be integers, @code{void *} pointers,
or pointers to some sort of polymorphic object.

It is up to the application to make sure the stack positions
in Libmarpa's steps exist and are initialized as desired
by the application.
This means extending the stack as needed for writes,
but also for reads.
Because of optimizations, it is quite possible for a
Libmarpa step to identify a stack position which has
never been written to as the operand of a rule.
This can happen, for example, if the rule's
operand is a ``whatever''
value.
(It is expected that in such a case that the rule's value
does not depend on that operand, though it is up to the
application to ensure this.)

C programmers should be aware of a pitfalls specific to C.
Both C90 and C99 allow unitialized values to be ``trap'' values --
values which cause a trap (possibly an abend) when read.
A C application must take steps to ensure either that
the universe of values does not include trap values,
or that these trap values are never read.
Excluding trap values from a C program's universe of
values may require the application to make
sure that stack positions are properly initialized.

@node Whatever values,  , Universe of values, Semantics
@section Valued and unvalued symbols

Libmarpa symbols can have values,
which is the traditional way of doing semantics.
Libmarpa also allows symbols to be unvalued.
An @dfn{unvalued} symbol is one whose value
is unpredictable from instance to instance.
If a symbol is unvalued, we sometimes say that it
has ``whatever'' semantics.

Situations where the semantics can tolerate unvalued symbols
are surprisingly frequent.
For example, the top-level of many languages is a series
of major units, all of whose semantics are typically accomplished
via side effects.
The compiler is typically indifferent to the actual value produced
by these major units, and tracking them is a waste of time.
Similarly, the value of the separators in a list is typically
ignored.

Rules are unvalued if and only if their LHS symbols
are unvalued
When rules and symbols are unvalued,
Libmarpa optimizes their evaluation.

Tt is in principle unsafe to check the value 
of a symbol if it can be unvalued.
For this reason,
once a symbol has been treated as valued,
Libmarpa marks it as valued.
Similarly,
once a symbol has been treated as unvalued,
Libmarpa marks it as unvalued.
Once marked, a symbol's valued status is
@dfn{locked} and cannot be changed later.

The valued status of terminals is marked the first
time they are read.
The valued status of LHS symbols must be explicitly
marked by the application when initializing the
valuator -- this is Libmarpa's equivalent of
registering a callback.

LHS terminals are disabled by default.
If allowed, the user should be aware that the valued
status of a LHS terminal
will be locked in the recognizer
if it is used as a terminal,
and the symbols use as a rule LHS
in the valuator must be
consistent with the recognizer's marking.

Marpa reports an error when a symbol's use
conflicts with its locked valued status.
This usually is usually saving the programmer
some tricky debugging down the road.
It is possible that an application might want to mix
valued and unvalued uses of a symbol -- an application
might be able to differentiate them using the larger
context, or might be tolerant of a the uncertainty.
If there is interest,
a future extension might allow a locked
valued status to be overriden.

@node Threads, Error handling concepts, Semantics, Top
@chapter Threads

Libmarpa is thread-safe,
if used as described below.
The Libmarpa methods are not reentrant.

@menu
* C89 and thread-safety::       
* Base grammars cannot be shared between threads::  
@end menu

@node C89 and thread-safety, Base grammars cannot be shared between threads, Threads, Threads
@section C89 and thread-safety

Libmarpa is C89-compliant.
It uses no global data,
and it does not use those C library functions which
are inherently thread-unsafe.

Libmarpa calls only the routines
that are defined in the C89 standard
and that can be made thread-safe.
In most modern implementations these are thread-safe.
But the C89 standard does not require thread-safety,
and even most modern environments allow the user
to turn thread safety off.
To be thread-safe, Libmarpa must be compiled
and linked in an environment that provides
thread-safety.

@menu
* C89 and thread-safety::
@end menu

@node Base grammars cannot be shared between threads,  , C89 and thread-safety, Threads
@section Base grammars cannot be shared between threads
While Libmarpa can be used safely across
multiple threads,
a Libmarpa grammar cannot be.
Further, a Libmarpa time object can
only be used safely in the same thread
as its base grammar.
This is because all
time objects with the same base grammar share data
from that base grammar.

To work around this limitation,
the same grammar definition can be
used to a create a new
Libmarpa grammar
time object in each thread.
If there is sufficient interest, future versions of
Libmarpa could allow thread-safe
cloning of grammars and other
time objects.

@node Error handling concepts, Introduction to the external interface, Threads, Top
@chapter Error handling

@menu
* Memory allocation failures::  
* Success and failure::         
* Soft and hard failure.::      
@end menu

@node Memory allocation failures, Success and failure, Error handling concepts, Error handling concepts
@section Memory allocation failures

Libmarpa leaves the decision of what is a fatal
error up to the application,
with one exception.
Currently, if @code{malloc} fails to allocate memory,
Libmarpa terminates the program with a fatal error.

While this is in keeping with current practice,
future versions of Libmarpa are likely to both allow
an alternative memory allocator to be specificied,
and to allow the user to specifier a handler to
be called when an out-of-memory condition occurs.

@node Success and failure, Soft and hard failure., Memory allocation failures, Error handling concepts
@section Success and failure

In this document, success and failure are (unless
the context makes it clear otherwise) used in a special, technical
sense, one which may differ from the usual one.
In ordinary language, ``success'' is a desired result,
and ``failure'' an undesired one.

In this document, @dfn{success}
successfully followed its primary logic path to an end result.
@dfn{Failure} means some other logic path was followed.

As one example where the distinction is relevant,
some methods are designed so that they can be used
to control a loop.  Success means continue the loop,
while a soft failure indicates loop terminate.
It is typically a good thing for loops to terminate,
so that the soft failure is very much a ``desired result''.
As another example,
the ``Ruby Slippers'' parsing method uses soft failures
as a means of testing alternative inputs and/or
checking the state of the parse.

@node Soft and hard failure.,  , Success and failure, Error handling concepts
@section Soft and hard failure.

Some methods have, in addition to a primary logic path,
a secondary one.
If a result is returned from a secondary logic path,
that is a soft failure.
As previously stated, a soft failure may be,
in the ordinary sense of the word ``failure'',
no failure at all but very much a desired
and expected result.

All methods have a primary logic path,
but for some methods no logic path is distinguished
as the ``secondary'' one.
These methods never return a soft failure.
A hard failure results when a method returns a value
from some logic path other than the primary or secondary
one.

Whenever a method returns a hard failure,
Libmarpa sets the error code to indicate
the nature of the failure.
Soft failures typically have a single
cause, and usually are indicated by a return
value special to soft failures,
and in those cases an error code is not needed.
In the cases where it is not
necessary,
the error code is not set.

An application will have its own ideas of success,
primary and secondary logic paths,
what is or is not a recoverable failure,
and what is or is not a fatal error.
As much as possible, Libmarpa makes it
possible for the application to capture
its results and reinterpret them to suit
the application's purpose.

Because of the variability of applications, there are no hard and
fast rules.  However, if taken with a grain of salt, a few
generalizations may be helpful.  Soft failures disrupt the normal
flow of processing less often than hard failures.  Hard failures
only rarely are part of an application's primary logic path, and
very often indicate an unrecoverable error.
There are many case in which
soft failures are part of an application's primary logic path, and
even more where they are part of a secondary logic path, and even
more where they are recoverable.  But it is also true that many
soft failures are unrecoverable errors from the point of view of
the application.

@node Introduction to the external interface, Static method, Error handling concepts, Top
@chapter Introduction to the external interface

The following chapters describe Libmarpa's external
interface in detail.

@menu
* About the overviews::         
* Return values::               
@end menu

@node About the overviews, Return values, Introduction to the external interface, Introduction to the external interface
@section  About the overviews

The reference method sections usually begin with an overview
describing the important methods.
These sections can be describe the
most important Libmarpa methods,
in the order in which they are typically used,
and can be used as ``cheat sheet''.

The overview sections limit themselves to
the most important methods.
To guide the reader to those methods
that he is most likely to find essential
for his application,
the overview sections often speak of
an ``archetypal'' application.
The archetypal Libmarpa application
implements the complete logic flow,
from the creation of a grammar to a final result
from its valuation.
In the archetypal Libmarpa application,
grammar, input and semantics are
all small but non-trivial.

@node Return values,  , About the overviews, Introduction to the external interface
@section Return values

If a function returns an integer value,
and it is not otherwise stated,
-1 indicates a soft failure,
-2 indicates a hard failure
and a non-negative result indicates success.
If a function returns an pointer value,
and it is not otherwise stated,
@code{NULL} indicates a failure,
and any other result indicates success.
Exceptions to these rules
will be explicitly indicated.

Where a method returns @code{NULL},
and in its description
there is no mention of soft failure,
the reader can assume that the method never
returns soft failure.
If a method allows soft failure,
the cause of the soft failure will always be described,
either in the description of a -1 return,
or explicitly.

Hard failure often can have many causes,
and full descriptions of all of them under each
method would hopelessly
clutter the method descriptions.
The Libmarpa error code is always set after
a hard failure,
and a full descriptions of the causes of each
error code is in its own section.
@xref{Error Codes}.

@node Static method, Grammar methods, Introduction to the external interface, Top
@chapter Static method

@deftypefun Marpa_Error_Code marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro} @
    )

Checks that the Marpa library in use is compatible with the
given version. Generally you would pass in the constants
@code{MARPA_MAJOR_VERSION},
@code{MARPA_MINOR_VERSION},
@code{MARPA_MICRO_VERSION}
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of Libmarpa the application or module was compiled
against.

Currently Libmarpa is undergoing rapid development,
and backward compatibility is not maintained.
This will be the case as long as Libmarpa stays
alpha.
While Libmarpa is alpha
the major, minor and micro numbers must match exactly.

Once Libmarpa is beyond alpha releases,
compatibility will be defined by two things:
first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Return value: @code{MARPA_ERR_NONE} if the Marpa library is compatible with the
requested version.  If the library is not compatible,
one of the following is returned, indicating the nature of the mismatch:
@itemize
@item @code{MARPA_ERR_MAJOR_VERSION_MISMATCH},
@item @code{MARPA_ERR_MINOR_VERSION_MISMATCH}
@item @code{MARPA_ERR_MICRO_VERSION_MISMATCH}
@end itemize

@end deftypefun

@node Grammar methods, Recognizer methods, Static method, Top
@chapter Grammar methods
@cindex grammars

@menu
* Grammar overview::            
* Grammar constructor::         Creating a new grammar.
* Grammar reference counting::  Tracking the reference count of the grammar.
* Symbols::                     
* Terminals methods::           
* Rules::                       
* Sequences::                   
* Grammar precomputation::      Precomputing the Grammar.
* Grammar events::              
@end menu

@node Grammar overview, Grammar constructor, Grammar methods, Grammar methods
@section Overview

An archtypal application has a grammar.
To create a grammar, use the @code{marpa_g_new()} method.
When a grammar is no longer in use, its memory can be freed
using the 
@code{marpa_g_unref()} method.

To be precomputed,
a grammar must have one or more symbol.
To create symbols, use the
@code{marpa_g_symbol_new()} method.

To be precomputed,
a grammar must have one or more rules.
To create rules, use the
@code{marpa_g_rule_new()} and
@code{marpa_g_sequence_new()} methods.

For non-trivial parsing,
one or more of the symbols must be terminals.
To mark a symbols a terminal,
use the
@code{marpa_g_symbol_is_terminal_set()} method.

To be precomputed,
a grammar must have exactly one start symbol.
To mark a symbol as the start symbol,
use the
@code{marpa_g_start_symbol_set()} method.

Before parsing with a grammar, it must be precomputed.
To precompute a grammar,
use the
@code{marpa_g_precompute()} method.

@node Grammar constructor, Grammar reference counting, Grammar overview, Grammar methods
@section Creating a new grammar
@cindex grammar constructor

@deftypefun Marpa_Grammar marpa_g_new ( @
    unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro})

Creates a new grammar time object.
The returned grammar object is not yet precomputed,
and will have no symbols and rules.
Its reference count will be 1.

The expected major, minor and micro version
numbers must be passed as arguments,
While Libmarpa is alpha,
any mismatch with the actual version will
cause a failure.

Return value: On success, the grammar object.
On failure, @code{NULL}.

@end deftypefun

@node Grammar reference counting, Symbols, Grammar constructor, Grammar methods
@section Tracking the reference count of the grammar
@cindex grammar destructor
@cindex grammar reference
@cindex grammar reference count

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
Decreases the reference count by 1,
destroying @var{g} once the reference count reaches
zero.

@end deftypefun

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, the grammar object it was called with;
@code{NULL} on failure.

@end deftypefun

@node Symbols, Terminals methods, Grammar reference counting, Grammar methods
@section Symbols

@deftypefun Marpa_Symbol_ID marpa_g_symbol_new (Marpa_Grammar @var{g})

Creates a new symbol.

Return value: On success, the ID of a new symbol;
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{id})

Sets the start symbol of grammar @var{g} to symbol @var{id}.

Return value: On success, the ID of the new start symbol.
On failure, -2.

@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_start_symbol (Marpa_Grammar @var{g})

Returns current value of the start symbol of grammar @var{g}.
The value is that of the user's start
symbol, as specified in the @code{marpa_g_start_symbol_set()} call,
if there has been one.

Return value:
On failure, -2;
-1 if there is no start symbol yet;
otherwise the ID of the new start symbol.
@end deftypefun

@deftypefun int marpa_g_symbol_count (Marpa_Grammar @var{g})
Return value:
On success, the symbol count of the grammar.
On failure, -2.
@end deftypefun

@node Terminals methods, Rules, Symbols, Grammar methods
@section Methods for terminal symbols

@deftypefun int marpa_g_symbol_is_terminal ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
Return value: On success, 1 if @var{symid} is a terminal symbol, 0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_terminal_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid}, @
 int @var{value})
This function flags symbol @var{symid} as a terminal if
@var{value} is 1,
or flags it as a non-terminal if @var{value} is 0.
By default, a symbol is a terminal if and only if it
does not appear on the LHS of any rule.
This setting overrides the default.
An attempt to flag a nulling symbol
as a terminal is a fatal error,
but this is not necesssarily detected before precomputation.

Return value: On success, 1 if @var{symid} is a terminal symbol after the
call, 0 otherwise.
If @var{value} is not 0 or 1;
if the grammar @var{g} is precomputed;
or on some other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{accessible} if it can be reached from the start symbol.

Return value: On success, 1 if accessible, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{productive} if it can produce a string of terminals.
All nullable symbols are considered productive.

Return value: On success, 1 if productive, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_start ( Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})

This return value of this call indicates whether @var{symid}
is the start symbol.

Return value: -2 if @var{symid} is not valid;
    1 if @var{symid} is the start symbol;
    0 otherwise.

@end deftypefun

@deftypefun int marpa_g_symbol_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{nulling} if it always produces the empty string.

Return value: On success, 1 if symbol is nulling, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_nullable ( @
  Marpa_Grammar g, Marpa_Symbol_ID symid)
A symbol is @dfn{nullable} if it sometimes produces the empty string.
A @strong{nulling} symbol is always a @strong{nullable} symbol,
but not all @strong{nullable} symbols are @strong{nulling} symbols.

Return value: On success, 1 if symbol is nullable, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_valued_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id}, @
    int value)
@deftypefunx int marpa_g_symbol_is_valued ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symbol_id})

These methods, respectively, set
and query the ``valued status'' of a symbol.
If a symbol is ``valued'',
the semantics require that it have a defined value.
If a symbol is not valued,
it is an unvalued, or a ``whatever'' symbol.

Return value: On success, 1 if the symbol @var{symbol_id}
is valued, 0 if not.
On failure, -2.

@end deftypefun

@node Rules, Sequences, Terminals methods, Grammar methods
@section Rules

@deftypefun int marpa_g_rule_count (Marpa_Grammar @var{g})
Return value: On success, the current number of rules in grammar @var{g}.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_g_rule_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs}, @
 Marpa_Symbol_ID *@var{rhs}, @
     int @var{length})
Creates a new external rule in grammar @var{g}.
The LHS symbol is @var{lhs},
and there are @var{length} symbols on the RHS,
which is pointed to by @var{rhs}.

An attempt to add a duplicate rule is a hard failure.
A rule is considered a duplicate if it has the same
LHS symbol,
and the same RHS symbols in the same order.
A rule is also considered a duplicate if it has
the same LHS symbol as a sequence rule,
regardless of the right hand sides of the
two rules.

Return value:  On success, the ID of new external rule.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value: On success, the LHS symbol of the rule.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
The length of a rule is the number of symbols on its RHS.

Return value: On success, the rule length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_g_rule_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id}, @
    int @var{ix})
The position in the rule, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
rule, it is a soft failure.
This can be used in loops, to avoid having to determine
the rule's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the rules RHS.
If @var{ix} is greater than or equal to the length of
the rule, -1.
On other failures, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_nulling (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{ruleid})
A rule is @dfn{nulling} if it always produces the empty string.

Return value: On success, 1 if @var{ruleid} is nulling, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_nullable ( @
  Marpa_Grammar g, Marpa_Rule_ID ruleid)
A rule is @dfn{nullable} if it sometimes produces the empty string.
A @strong{nulling} rule is always a @strong{nullable} rule,
but not all @strong{nullable} rules are @strong{nulling} rules.

Return value: On success, 1 if @var{ruleid} is nullable, 0 if not.
If the grammar is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_accessible (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{accessible} if it can be reached from the start symbol.
A rule is accessible if and only if its LHS symbol is accessible.
The start rule is always an accessible rule.

Return value: On success, 1 if accessible, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_productive (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{id})
A rule is @dfn{productive} if it can be produce a string of terminals.
including the empty string.
An rule is productive if and only if all the symbols on
its RHS are productive.
An empty rule is considered productive.

Return value: On success, 1 if productive, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_loop (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
A rule is a loop rule if it non-trivially
produces the string of length one
which consists only of its LHS symbol.
``Non-trivially'' means the zero-step derivation does not count -- the
derivation must have at least one step.

The presence of a loop rule makes a grammar infinitely ambiguous,
and applications will typically want to treat them as fatal errors.
But nothing forces an application to do this,
and Marpa will successfully parse and evaluate grammars with
loop rules.

Return value: On success, 1 if this is a loop rule, 0 if not.  If the grammar
is not precomputed, or on other failure, -2.
@end deftypefun

@node Sequences, Grammar precomputation, Rules, Grammar methods
@section Sequences

@deftypefun Marpa_Rule_ID marpa_g_sequence_new (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{lhs_id}, @
 Marpa_Symbol_ID @var{rhs_id}, @
     Marpa_Symbol_ID @var{separator_id}, @
    int @var{min}, @
 int @var{flags} )
Adds a new sequence rule to grammar @var{g}.
Internally, Libmarpa translates sequences into BNF
rules, but it also optimizes their evaluation.
In practice this speedup can be considerable.

The sequence is @var{lhs_id},
and the item to be repeated in the sequence is @var{rhs_id}.
The sequence must be repeated at least @var{min} times,
where @var{min} is 0 or 1.
If @var{separator_id} is non-negative,
it is a separator symbol.

If @code{flags & MARPA_PROPER_SEPARATION} is non-zero,
separation is ``proper'', that is,
a trailing separator is not allowed.
The term @dfn{proper} is based on the idea that
properly-speaking, separators should actually separate items.

The sequence RHS, or item,
is restricted to a single symbol,
but almost
any language and any semantics
can be expressed indirectly,
by using @var{rhs_id} be the LHS of another rule.
@var{rhs_id} cannot be a nullable symbol.
If @var{separator_id} is a symbol, it also cannot
be a nullable symbol.

Nullables on the RHS of sequences are restricted
because they lead to highly ambiguous grammars.
Such grammars are allowed by Libmarpa, but
they must be expressed using BNF rules, not sequence rules.
This is for two reasons:
First, sequence optimizations would not work
in the presence of nullables.
Second, since it is not completely clear what
an application intends
when it asks for a sequence of identical items,
some of which are nullable,
the user's intent can be more clearly expressed
directly in BNF.

Return value:  On success, the ID of the external rule.
If the rule duplicates another rule,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_sequence ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:  1 if @var{rule_id} is a sequence rule,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_symbol_is_counted (Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
A symbol is @dfn{counted}
if it appears on the RHS of a sequence rule.
The separator symbol of a sequence rule is also considered
to be a counted symbol.

Return value: On success, 1 if the symbol is counted, 0 if not.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_rule_is_proper_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
Return value:
Returns 1 if
the proper separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On hard failure, returns -2.
@end deftypefun

@node Grammar precomputation, Grammar events, Sequences, Grammar methods
@section Precomputing the Grammar

@deftypefun int marpa_g_precompute (Marpa_Grammar @var{g})
This function precomputes the grammar.

In the process, precomputation creates events which
the user can access.
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether precomputation fails or succeeds.
When the method fails,
the application must call @code{marpa_g_event()}
if it wants to determine if any events occurred.
Since the reason for failure to precompute is often
detailed in the events, failed applications will often
be at least as interested in the events as those
which succeeded.

A @code{MARPA_EVENT_LOOP_RULES} event occurs
when there are infinite loop rules (cycles)
in the grammar.
Cycles make a grammar infinitely ambiguous.
They are considered useless in current
practice,
and make processing the grammar less
efficient, sometimes considerably so.
Most applications will want to treat them
as errors.
Nonetheless, they are not errors in Libmarpa,
and do not prevent Libmarpa from parsing.

Each @code{MARPA_EVENT_COUNTED_NULLABLE} event is a symbol
which is a nullable on the right hand side of a sequence
rule -- a ``counted'' symbol.
The presence of one or more of these is a hard failure.
So that the programmer can fix several at once,
these failures are delayed until events are created
for all of the counted nullables.

Each @code{MARPA_EVENT_NULLING_TERMINAL} event is a nulling
symbol which is also flagged as a terminal.
Since terminals cannot be of zero length, this is a logical
impossibility, and
the presence of one or more of these is a hard failure.
So that the programmer can fix several at once,
the failure is delayed until events are created
for all of the counted nullables.

Precomputation involves freezing
and then thoroughly checking the grammar,
and it is at this point that many failures
are caught and reported.
Counted nullables and nulling terminals have
already been mentioned.
Grammars without rules and those
with invalid start symbols also produce
hard failures.

Return value: On success, the number of events generated.
If the grammar is already precomputed,
or on other failure, -2.
@end deftypefun

@deftypefun int marpa_g_is_precomputed (Marpa_Grammar @var{g})
Return value: On success, 1
if grammar @var{g} is already precomputed,
0 otherwise.
On failure, -2.
@end deftypefun

@deftypefun int marpa_g_has_cycle (Marpa_Grammar @var{g})
This function allows the application to determine if grammar
@var{g} has a cycle.
As mentioned, most applications will want to treat these
as fatal errors.
To determine which rules are in the cycle,
@var{marpa_g_rule_is_loop()} can be used.

Return value: On success, 1 if the grammar has a cycle,
0 otherwise.
On failure, -2.
@end deftypefun

@node Grammar events,  , Grammar precomputation, Grammar methods
@section Events

@deftypefun int marpa_g_event (Marpa_Grammar @var{g}, @
    Marpa_Event* @var{event}, @
	       int @var{ix})
This method provides access to the events generated
by the @code{marpa_g_precompute()} method.
The @var{ix}'th event (numbered from 0) is placed
in the @var{event} value.

It is a soft failure if there is no such event.
This can be used as the termination condition
in a loop over the events.

Return value:  On success, returns the type of event @var{ix},
and places the data for the event in @var{event}.
If there is no such event, returns -1.
On hard failure, returns -2.
@end deftypefun

@deftypefn {Macro} void* marpa_g_event_value (Marpa_Event* @var{event})
This macro provides access to the ``value'' of the event.
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes.
@xref{Events}.
@end deftypefn

@node Recognizer methods, Progress reports, Grammar methods, Top
@chapter Recognizer methods

@menu
* Recognizer overview::         
* Recognizer constructor::      Creating a new recognizer.
* Recognizer reference counting::  Keeping the reference count of a recognizer.
* Recognizer life cycle mutators::  
* Location accessors::          
* Other parse status methods::  
* Recognizer events::           
@end menu

@node Recognizer overview, Recognizer constructor, Recognizer methods, Recognizer methods
@section Overview

An archtypal application uses a recognizer to read input.
To create a recognizer, use the @code{marpa_r_new()} method.
When a recognizer is no longer in use, its memory can be freed
using the 
@code{marpa_r_unref()} method.

In order to allow future extensions that change settings
before the recognizer is set up for input,
when the recognizer is created,
it is @strong{not} created ready for input.
To make a recognizer ready for input,
Use the @code{marpa_r_start_input()} method.

The recognizer starts with its current earleme
at location 0.
To read a token at the current earleme,
use the @code{marpa_r_alternative()} call.

To complete the processing of the current earleme,
and move forward to a new one,
use the @code{marpa_r_earleme_complete()} call.

@node Recognizer constructor, Recognizer reference counting, Recognizer overview, Recognizer methods
@section Creating a new recognizer

@deftypefun Marpa_Recognizer marpa_r_new ( Marpa_Grammar @var{g} )
Creates a new recognizer.
The reference count of the recognizer will be 1.
The reference count the the base grammar, @var{g},
will be incremented by one.

Return value:  On success, the newly created recognizer.
If @var{g} is not precomputed, or on other failure, @code{NULL}.
@end deftypefun

@node Recognizer reference counting, Recognizer life cycle mutators, Recognizer constructor, Recognizer methods
@section Keeping the reference count of a recognizer

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, the @var{r};
@code{NULL} on failure.
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
Decreases the reference count by 1,
destroying @var{r} once the reference count reaches
zero.
When @var{r} is destroyed, the reference count
of its base grammar is decreased by one.
It this takes the reference count of the base grammar
to zero, it too is destroyed.

@end deftypefun

@node Recognizer life cycle mutators, Location accessors, Recognizer reference counting, Recognizer methods
@section Life cycle mutators

@deftypefun int marpa_r_start_input (Marpa_Recognizer @var{r})
Makes @var{r} ready to accept input.

Return value:  On success, a non-negative value.
On failure, -2.
@end deftypefun

@deftypefun int marpa_r_alternative (Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID @var{token_id}, @
    int @var{value}, @
    int @var{length})
Reads a token into @var{r}.
The token will start at the current earleme.
Libmarpa allows tokens to be ambiguous, to be of
variable length and to overlap.
@var{token_id} is the symbol of the token,
which must be a terminal.
@var{length} is the length of the token.

@var{value} is an
integer which represents the value of the
token.
In applications where the token's value is not an integer, it is
expected that the application will use this value to
find the application's value, perhaps by using @var{value}
to index an array.
@var{value} is not used inside Libmarpa -- it is simply
stored to be returned by the valuator
as a convenience for the application.
Some applications will not want to use Libmarpa's token
values, instead tracking their own, perhaps based on
the earleme location, and @var{token_id}.

A @var{value} of 0 has special significance -- it indicates
that the token is unvalued -- that its value is allowed
to be unpredictable.
Note that if a token is unvalued,
it must be the case,
not just that Libmarpa need not care about its value,
but also that @strong{the application}
does not care about the value of the token.
When a token has a ``whatever'' value, Libmarpa 
optimizes away the valuator steps which
give the application an opportunity to provide
a value for that token.
Applications which do not use Libmarpa's token values,
but which @strong{do} care about the token's value,
must tell Libmarpa not to optimize away the
relevant valuator steps.
An application can do this by
letting @var{value} be any non-zero integer.

If, on the first read by
@code{marpa_r_alternative()},
symbol @var{token_id} is not already locked,
the valued status
of symbol @var{token_id}
will be set according to its
use in that call
to @code{marpa_r_alternative()},
and symbol @var{token_id}
will be locked in that valued status.
Once symbol
@var{token_id} is locked in valued status,
it must be used as a valued symbol.
Similarly, once symbol
@var{token_id} is locked in unvalued status,
it must be used as a unvalued symbol.

When @code{marpa_r_alternative()}
is successful,
the value of furthest earleme is set to
the greater of its value before the call,
and @var{current}+@var{length},
where @var{current} is the value of the current earleme.
The values of the current and latest earlemes
are unchanged by
calls to @code{marpa_r_alternative()}.

Return value:  On success, returns a non-negative value.
If the token was not accepted because @var{token_id} is unexpected,
it is considered a soft failure,
and @code{marpa_r_alternative()} returns -1.
If the token was not accepted because it
is a duplicate,
it is considered a soft failure,
and @code{marpa_r_alternative()} returns -3.
Other problems that prevent successful processing,
are considered hard failures,
and -2 is returned.

@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (Marpa_Recognizer @var{r})
This method does the final processing for the current earleme.
It then advances the current earleme by one.
Note that @code{marpa_r_earleme_complete()} may be called
even when no tokens have been read at the current earleme --
in the character-per-earleme input model, for example, tokens
can span many characters and, if the input is unambiguous over that
span, there will be no other tokens that start inside it.

As mentioned,
@code{marpa_r_earleme_complete()} always advances the current earleme,
incrementing its value by 1.
This means that value of the current earleme after the call
will be the one plus the value of the earleme processed by the call
to @code{marpa_r_earleme_complete()}.
If any token was accepted at the earleme being processed,
@code{marpa_r_earleme_complete()} creates a new Earley set
which will be the latest Earley set,
and, after the call, the latest
earleme will be equal to the new current earleme.
If no token was accepted at the
earleme being processed,
no Earley set is created,
and the value of the latest earleme remains unchanged.
The value of the furthest earleme is never changed by
a call to @code{marpa_r_earleme_complete()}.

During this method, one or more events may occur.
On success, this function returns the number of events
generated,
but it is important to note that events may be
created whether earleme completion fails or succeeds.
When this method fails,
the application must call @code{marpa_r_event()}
if it wants to determine if any events occurred.
Since the reason for failure to complete an earleme is often
detailed in the events, applications that fail will often
be at least as interested in the events as those
that succeed.

@code{MARPA_EVENT_EXHAUSTED} indicates that the parse is
exhausted -- that no input will be accepted at later earlemes.
Note that an exhausted parse can be a successful one -- it
just cannot succeed at a later earleme than the current one.

The @code{MARPA_EVENT_EARLEY_ITEM_THRESHOLD} event
indicates that an application-settable threshold
on the number of Earley items has been reached or exceeded.
What this means depends on the application,
but when the default threshold is exceeded,
it means that it is very likely
that the time and space resources consumed by
the parse will prove excessive.

Return value:  On success, the number of events generated.
On failure, -2.
@end deftypefun

@node Location accessors, Other parse status methods, Recognizer life cycle mutators, Recognizer methods
@section Location accessors

@deftypefun Marpa_Earleme marpa_r_earleme ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{set_id})

In the default, token-stream model, Earley set ID and earleme
are always equal, but this is not the case in other input
models.

At this writing, there is no method for
the inverse operation (conversion of an earleme to an Earley set
ID).
One consideration in writing
such a method is that not all earlemes correspond to Earley sets.
Applications using the standard input model
can take advantage of the exact equivalence of Earley set
ID's and earlemes in that model.
Other applications may need to create an ID-to-earleme
array using the @code{marpa_r_earleme()} method,
and invert it themselves.

Return value:
On success,
returns the earleme corresponding to Earley
set @var{set_id}.
If @var{set_id} is out of bounds,
returns -1.
On other failures, returns -2.
@end deftypefun

@deftypefun @code{unsigned int} marpa_r_current_earleme (Marpa_Recognizer @var{r})
Return value: On success, the current earleme.
If input has not started, -1.
Always succeeds or fails softly.
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_latest_earley_set (Marpa_Recognizer @var{r})
The value of the latest earleme can be found by converting ID using
the @code{marpa_r_earleme()} method.

Return value: On success, the ID of the latest earley set.
Always succeeds.
@end deftypefun

@deftypefun @code{unsigned int} marpa_r_furthest_earleme (Marpa_Recognizer @var{r})
Return value: On success, the furthest earleme.
Always succeeds.
@end deftypefun

@node Other parse status methods, Recognizer events, Location accessors, Recognizer methods
@section Other parse status methods

@deftypefun int marpa_r_earley_item_warning_threshold (Marpa_Recognizer @var{r})
@deftypefunx int marpa_r_earley_item_warning_threshold_set (Marpa_Recognizer @var{r}, @
    int @var{threshold})
These methods, respectively, report and set the earley item warning threshold.
The @dfn{Earley item warning threshold}
is a number that is compared with
the count of Earley items in each Earley set.
When it is matched or exceeded,
a @code{MARPA_EVENT_EARLEY_ITEM_THRESHOLD} event is created.

If @var{threshold} is zero or less,
an unlimited number of Earley items
will be allowed without warning.
This will rarely be what the user wants.
By default, Libmarpa calculates a value based on the grammar.
The formula Libmarpa uses is the result of some experience,
and most applications will
be happy with it.

Return value:
The value that the Earley item warning threshold has
after the method call is finished.
Always succeeds.
@end deftypefun

@deftypefun int marpa_r_terminals_expected ( @
    Marpa_Recognizer @var{r}, @
    Marpa_Symbol_ID* @var{buffer})
Returns a list of the ID's of the symbols
which are acceptable as tokens
at the current earleme.
@var{buffer} is expected to be large enough to hold
the result.
This is guaranteed to be the case if the buffer
is large enough to hold a number of
@code{Marpa_Symbol_ID}'s that
is greater than or equal to the number of symbols
in the grammar.

Return value:  On success, the number of @code{Marpa_Symbol_ID}'s
in @var{buffer}.
On failure, -2.
@end deftypefun

@deftypefun int marpa_r_is_exhausted (Marpa_Recognizer @var{r})
A parser is ``exhausted'' if it cannot accept any more input.
Both successful and failed parses can be exhausted.
In many grammars,
the parse is always exhausted as soon as it succeeds.
And even if the parse is exhausted at a point
where there is no good parse,
there may be good parses at earlemes prior to the
earleme at which the parse became exhausted.

Return value:
1 if the parser is exhausted, 0 otherwise.
Always succeeds.
@end deftypefun

@node Recognizer events,  , Other parse status methods, Recognizer methods
@section Events

@deftypefun int marpa_r_event (Marpa_Recognizer @var{r}, @
    Marpa_Event* @var{event}, @
	       int @var{ix})
This method provides access to the events generated
by the @code{marpa_r_earleme_complete()} method.
The @var{ix}'th event (numbered from 0) is placed
in the @var{public_event} value.
It is a soft failure if there is no
@var{ix}'th event.
This can be used as the termination condition
in a loop over the events.

Return value:  On success, returns the type of event @var{ix},
and places the data for the event in @var{public_event}.
If there is no such event,
-1 is returned.
On hard failure, -2 is returned.
On failure,
the value pointed to be @var{public_event} is unspecified.
@end deftypefun

@deftypefn {Macro} int marpa_r_event_value (Marpa_Event* @var{event})
This macro provides access to the ``value'' of the event.
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes.
@xref{Events}.
@end deftypefn

@node Progress reports, Bocage methods, Recognizer methods, Top
@chapter Progress reports

An important advantage of the Marpa algorithm is the ability
to easily get full information about the state of the parse
so far.
Only one progress report can be in use at any one time.
To start a progress report,
use the @code{marpa_r_progress_report_start()} command.

To get the information in a progress report,
step through its items with
the @code{marpa_r_progress_item()} method.

To destroy a progress report,
freeing the memory it uses,
call the @code{marpa_r_progress_report_finish()} method.

@deftypefun int marpa_r_progress_report_start ( @
  Marpa_Recognizer @var{r}, @
  Marpa_Earley_Set_ID @var{set_id})
Initializes a report of the progress at Earley set @var{set_id}
for recognizer @var{r}.
If a progress report already exists, it is destroyed and its
memory is freed.
Initially,
the progress report is positioned before its first item.

Return value: On success, the number of report items available.
If @var{set_id} is a non-negative number,
but a corresponding Earley set does not exist, -1.
If the recognizer has not been started,
if @var{set_id} is less than zero,
or on other hard failure, -2.
@end deftypefun

@deftypefun int marpa_r_progress_report_finish ( @
  Marpa_Recognizer @var{r} )
Destroys the report of the progress at Earley set @var{set_id}
for recognizer @var{r},
freeing the memory and other resources.
It is often not necessary to call this method.
Any previously existing progress report
is destroyed automatically
whenever a new progress report is started,
and when the recognizer is destroyed.

Return value: -2 if no progress report has been started,
or on other hard failure.
On success, a non-negative value.
@end deftypefun

@deftypefun Marpa_Rule_ID marpa_r_progress_item ( @
  Marpa_Recognizer @var{r}, @
  int* @var{position}, @
  Marpa_Earley_Set_ID* @var{origin} )
This method allows access to the data
for the next item of a
progress report.
If there are no more progress report items,
it returns -1 to indicate a soft failure.
Either the soft failure,
or the item count returned by
@code{marpa_r_progress_report_start()},
can be used to determine when the last
item has been seen.

Return value: On success, the rule ID of
the next progress report item.
If there are no more progress report items, -1.
If either @var{position} or @var{origin} is @code{NULL},
or on other hard failure, @code{-2}.
On success,
the dot position is returned in the location
pointed to by @var{position},
and the origin is returned in the location
pointed to by @var{origin}.
On failure, it is not specified what, if any,
value is written to
@var{position} and @var{origin}.
@end deftypefun

@node Bocage methods, Ordering methods, Progress reports, Top
@chapter Bocage methods

@menu
* Bocage overview::             
* Bocage reference counting::   
@end menu

@node Bocage overview, Bocage reference counting, Bocage methods, Bocage methods
@section Overview

As a byproduct of recognition,
the recognizer has tables.
Before parsing, an archtypal application must create
a bocage.
A bocage is structure containing all the parses found
for the input.

Because Libmarpa parses ambiguous grammars, the bocage may
contain many parses.
(For those familiar with them, a bocage is
a specialized and extended parse forest.)

To create a bocage, use the @code{marpa_b_new()} method.
When a recognizer is no longer in use, its memory can be freed
using the 
@code{marpa_b_unref()} method.

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Earley_Set_ID @var{ordinal_arg})

Creates a new bocage object, with a reference count of 1.
The reference count of its parent recognizer object, @var{r},
is increased by 1.

Return value: On success, the new bocage object.
On soft failure, returns @code{NULL} and sets the error
code to @code{MARPA_ERR_NO_PARSE}.
On other failure, returns @code{NULL} and sets the error
appropriately.
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
Return value: The base grammar of @var{b}.
Always succeeds.
@end deftypefun

@node Bocage reference counting,  , Bocage overview, Bocage methods
@section  Reference counting
@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{b}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
Decreases the reference count by 1,
destroying @var{b} once the reference count reaches
zero.
When @var{b} is destroyed, the reference count
of its parent recognizer is decreased by 1.
It this takes the reference count of the parent recognizer
to zero, it too is destroyed.
If the parent recognizer is destroyed, the reference count
of its base grammar is decreased by 1.
It this takes the reference count of the base grammar
to zero, it too is destroyed.

@end deftypefun

@node Ordering methods, Tree methods, Bocage methods, Top
@chapter Ordering methods

@menu
* Ordering overview::           
* Ordering constructor::        
* Ordering reference counting::  
@end menu

@node Ordering overview, Ordering constructor, Ordering methods, Ordering methods
@section Overview

Before iterating the parses in the bocage,
they must be ordered.
To create an ordering, use the @code{marpa_o_new()} method.
When an ordering is no longer in use, its memory can be freed
using the 
@code{marpa_o_unref()} method.

An ordering is @dfn{frozen} once the first
tree iterator is created
using it.
A frozen ordering cannot be changed.

As of this writing, the only methods to order parses
are internal and undocumented.
This is expected to change in the near future.

@node Ordering constructor, Ordering reference counting, Ordering overview, Ordering methods
@section Creating an ordering

@deftypefun Marpa_Order marpa_o_new ( @
    Marpa_Bocage @var{b})
Creates a new ordering object, with a reference count of 1.
The reference count of its parent bocage object, @var{b},
is increased by 1.

Return value: On success, the new ordering object.
On failure, @code{NULL}.
@end deftypefun

@deftypefun Marpa_Grammar marpa_o_g ( @
    Marpa_Order @var{o})
Return value: The base grammar of @var{o}.
Always succeeds.
@end deftypefun

@node Ordering reference counting,  , Ordering constructor, Ordering methods
@section Reference counting

@deftypefun Marpa_Order marpa_o_ref ( @
    Marpa_Order @var{o})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{o}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_o_unref ( @
    Marpa_Order @var{o})
Decreases the reference count by 1,
destroying @var{o} once the reference count reaches
zero.
Beginning with @var{o}'s parent bocage,
Libmarpa then proceeds up the chain of parent objects.
Every time a child is destroyed, the
reference count of its parent is decreased by 1.
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed.
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

@end deftypefun

@node Tree methods, Value methods, Ordering methods, Top
@chapter Tree methods

@menu
* Tree overview::               
* Tree constructor::            
* Tree reference counting::     
* Tree iteration::              
@end menu

@node Tree overview, Tree constructor, Tree methods, Tree methods
@section Overview

Once the bocage has an ordering, the parses trees can be iterated.
Marpa's @dfn{parse tree iterators} iterate the parse trees contained
in a bocage object.
In Libmarpa,
``parse tree iterators'' are usually just called @dfn{trees}.

To create a tree, use the @code{marpa_t_new()} method.
When a tree is no longer in use, its memory can be freed
using the 
@code{marpa_t_unref()} method.

To position a new tree iterator to the first parse tree,
use the @code{marpa_t_next()} method.
To step through subsequent parse trees,
use the @code{marpa_t_next()} method.

@node Tree constructor, Tree reference counting, Tree overview, Tree methods
@section Creating a new tree iterator

@deftypefun Marpa_Tree marpa_t_new (Marpa_Order @var{o})
Creates a new tree iterator, with a reference count of 1.
The reference count of its parent ordering object, @var{o},
is increased by 1.

When initialized, a tree iterator is positioned
before the first parse tree.
To position the tree iterator to the first parse,
the application must call @code{marpa_t_next()}.

Return value:  On success, a newly created tree.
On failure, returns @code{NULL} and sets the error code.
@end deftypefun

@deftypefun Marpa_Grammar marpa_t_g (Marpa_Tree @var{t})
Return value: The base grammar of @var{t}.
Always succeeds.
@end deftypefun

@node Tree reference counting, Tree iteration, Tree constructor, Tree methods
@section Reference counting

@deftypefun Marpa_Tree marpa_t_ref (Marpa_Tree @var{t})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{t}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_t_unref (Marpa_Tree @var{t})
Decreases the reference count by 1,
destroying @var{t} once the reference count reaches
zero.
Beginning with @var{t}'s parent ordering,
Libmarpa then proceeds up the chain of parent objects.
Every time a child is destroyed, the
reference count of its parent is decreased by 1.
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed.
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

@end deftypefun

@node Tree iteration,  , Tree reference counting, Tree methods
@section Iterating through the trees

@deftypefun int marpa_t_next ( @
	Marpa_Tree @var{t})
Positions @var{t} at the next parse tree
in the iteration.
Tree iterators are initialized to the position
before the first parse,
so this method must be called before creating a valuator
from a tree.
If a tree iterator is positioned after the last parse,
the tree is said to be ``exhausted''.
A tree iterator for a bocage with no parse trees
is considered to be ``exhausted'' when initialized.

Return value: On success, returns a non-negative value.
If the tree is exhausted, returns -1.
On other failure, returns -2 and sets the error code.
@end deftypefun

@deftypefun int marpa_t_parse_count ( @
	Marpa_Tree @var{t})
The parse counter counts the number of parse trees
traversed so far.
The count includes the current iteration of the
tree, so that a value of 0 indicates that the tree iterator
is initialized to the position before the first parse tree.

Return value: The number of parses traversed so far.
Always succeeds.
@end deftypefun

@node Value methods, Events, Tree methods, Top
@chapter Value methods

@menu
* Value overview::              
* How to use the valuator::     
* Advantages of Libmarpa's valuator::  
* Details of stack manipulation::  
* Valuator constructor::        
* Valuator reference counting::  
* Registering semantics::       
* Stepping through the valuator::  
* Valuator steps by type::      
* Step accessors::              
@end menu

@node Value overview, How to use the valuator, Value methods, Value methods
@section Overview

The archetypal application needs
a value object (or @dfn{valuator}) to produce
the value of the parse.
To create a valuator, use the @code{marpa_v_new()} method.
When a valuator is no longer in use, its memory can be freed
using the 
@code{marpa_v_unref()} method.

By default, Libmarpa assumes that
non-terminal symbols have
no semantics.
The archetypal application will need to register
symbols that contain semantics.
The primary method for doing this is
@code{marpa_v_symbol_is_valued()}.
Applications registering semantics may find
it convenient to do so directly using
the @code{marpa_v_rule_is_valued()} method,
which will save them the trouble
of looking up the rule's LHS symbol.

The application is required to maintain the stack,
and the application is also required to implement
most of the semantics, including the evaluation
of rules.
Libmarpa's valuator provides instructions to
the application on how to manipulate the stack.
To iterate through this series of instructions,
use the @code{marpa_v_step()} method.

@code{marpa_v_step()} returns the type
of step.
Most step types has values associated with them.
To access these values use the methods
described in @ref{Step accessors}.
How to perform the steps is described in
@ref{How to use the valuator}
and @ref{Stepping through the valuator}.

@node How to use the valuator, Advantages of Libmarpa's valuator, Value overview, Value methods
@section How to use the valuator
Libmarpa's valuator provides the application with
``steps'', which are
instructions for stack manipulation.
Libmarpa itself does not maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
Libmarpa does not know that the operation
is an addition.
It will tell the application that rule number @math{R}
is to be applied to the arguments at stack locations
@math{N} and @math{N+1}, and that the result is to placed in
stack location @math{N}.

In this system
the application keeps track of the semantics for all
rules, so it looks up rule @math{R} and determines that it
is an addition.
The application can do this by using @math{R} as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule @math{R}.
Libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations @math{N} and @math{N+1} in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
Libmarpa has told the application that the result
belongs at location @math{N} in the stack,
so the application writes 753 to location @math{N}.

Since Libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers, or polymorphic objects which are
capable of being any of these things and more.

@node Advantages of Libmarpa's valuator, Details of stack manipulation, How to use the valuator, Value methods
@section Advantages of Libmarpa's valuator

This technique
hides Libmarpa's grammar rewrites from the application,
and is actually quite efficient.
Libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily
and, for these,
the series of steps
suggest by Libmarpa will be significantly faster than the standard
stack evaluation algorithm in the textbooks.

To make it clear,
we are under no illusion
that direct use of Libmarpa's valuator will be found
satisfactory by most application programmers,
even in the C language.
The author certainly avoids using it directly.
Libmarpa's valuator is intended
to be used via an upper layer,
one which @strong{does} know about semantics.

To see the advantage
of isolating Libmarpa from semantics,
suppose
that Libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, Libmarpa would have to deal in C callbacks,
and a middle layer would have to create C language wrappers
for the callbacks in the higher level language.
This intermixture of languages is very hard to handle,
especially when debugging.
Programmers typically react to these difficulties by
doing the minimum possible in the callbacks themselves,
and as much as possible in pre- and post-processing.
But this division of the work is usually undesirable
from other points of view,
sometimes highly so.
But the ability to debug can make the difference between
code that does work and code that does not,
and that consideration will typically trump others.

Libmarpa valuator's method of handling semantics
does well in terms of those other considerations.
Step-driven valuation may seem complex and indirect
at first, but the programmer will find that the
pushing the semantics up to a layer which knows more
about it simplifies many things.
Step-driven valuation also makes it unnecessary
to divide the logic 
between pre-processing, main processing,
and post-processing, unless the semantics
themselves suggest such an approach.
Finally, step-driven valuation
is usually slightly more efficient
when the callbacks are in C,
and is almost always significantly more efficient
when the callbacks would have to be
to a higher-level language.

@node Details of stack manipulation, Valuator constructor, Advantages of Libmarpa's valuator, Value methods
@section Details of stack manipulation

In manipulating the stack, if the application
is mantaining a conventional physical stack,
it is up
the application to ensure that all locations
that it writes to or reads from actually
exist.
In the form we have stated it,
this requirement sounds obvious,
However, the existence of unvalued symbols,
and the optimization of stack manipulations
involving them,
offers some room for surprise.
This section discusses the requirements for
safe stack manipulation in detail.

@menu
* Implications for literal stack manipulation::  
* Implications for non-literal implementations::  
@end menu

@node Implications for literal stack manipulation, Implications for non-literal implementations, Details of stack manipulation, Details of stack manipulation
@subsection Implications for literal stack manipulation

In this section,
we assume that
the application is keeping a physical stack,
and that the application is following the valuator's stack
manipulation instructions strictly and literally.
That is, when the application is told a rule's
arguments are in the locations from X to Y,
it reads locations from X to Y of a physical stack.
And when the application is told that the result
goes into stack location Z,
the application writes to location Z of a physical stack.
Many, if not most,
applications will implement their semantics
in exactly this way.

The application needs to be aware that the
valuator may ask it to read from an stack location
N, even though it was never instructed to write
to location N.
This will not be an issue if the stack is implemented as,
say, a Perl array, because Perl extends and initializes
arrays as necessary, on both read and write.
From the point of view of the programmer of a language
like Perl, therefore, the discussion
of this section will be a non-issue.

The situation for the C programmer is more complicated,
to put it mildly.
We assume the C programmer is using a dynamic array as
a stack.
Under these circumstances, a read from an never-written
location beyond the end of the array,
may cause a memory fault.
In fact, if the C programmer is following the standards,
she has to allow for ``trap values''.
That is, she must assume that uninitialized locations,
even within the
array bounds, may contain values which will cause an
abend on read.

The C programmer implementing Libmarpa semantics literally
and using a dynamic array as a stack, must ensure that
the stack is extended
@strong{and initialized to non-trap values}
before each write
and @strong{before each read}.
When implementing a rule's semantics,
it is sufficient to ensure that the rule's arguments
exist and are initialized on the stack.
The programmer is allowed to assume that stack location
for a rule's result will be at or before
the stack location of the rule's last argument.

This ``read with no previous write'' behavior occurs
because of unvalued symbols.
If a symbol is unvalued, the write to it may be
optimized away, but often the read from that location
may not be.
If the application has registered its valued symbols
properly, 
it will be indifferent to whatever value is
in the stack at the location
for the unvalued symbol.

@node Implications for non-literal implementations,  , Implications for literal stack manipulation, Details of stack manipulation
@subsection Implications for non-literal implementations

It is tempting to think there may be ways to
avoid reading never-written values
when using less-than-literal implementations.
The programmer needs to be aware that reads
beyond the end of stack are only part of the problem.
Specifically,
@itemize
@item Many of the locations of never-written values
will be within the stack.
@item Many of within-the-stack locations never written for a particular
value may have been used
for other values, and therefore will still have one
of those previous values.
@item Other never-written within-the-stack locations will never have
been written to for any value,
and therefore must be assumed by standard-conformant C code
potentially to contain trap values.
@end itemize

@node Valuator constructor, Valuator reference counting, Details of stack manipulation, Value methods
@section Creating a new valuator

@deftypefun Marpa_Value marpa_v_new ( @
    Marpa_Tree @var{t} @
)
Creates a new valuator.
The parent object of the new valuator
will be the tree iterator @var{t},
and the reference count of the new valuator will be 1.
The reference count of @var{t} is increased by 1.

The parent tree iterator is ``paused'',
so that the tree iterator
cannot move on to a new parse tree
until the valuator is destroyed.
Many valuators of the same parse tree
can exist at once.
A tree iterator is ``unpaused'' when
all of the valuators of a parse tree are destroyed.

Return value:  On success, the newly created valuator.
On failure, returns @code{NULL} and sets the error code.
@end deftypefun

@deftypefun Marpa_Grammar marpa_v_g ( @
    Marpa_Value @var{v} @
    )
Return value: The base grammar of @var{v}.
Always succeeds.
@end deftypefun

@node Valuator reference counting, Registering semantics, Valuator constructor, Value methods
@section Reference counting

@deftypefun Marpa_Value marpa_v_ref (Marpa_Value @var{v})
Increases the reference count by 1.
Not needed by most applications.

Return value:
On success, @var{v}.
On failure, @code{NULL}.
@end deftypefun

@deftypefun void marpa_v_unref ( @
    Marpa_Value @var{v})
Decreases the reference count by 1,
destroying @var{v} once the reference count reaches
zero.
Beginning with @var{v}'s parent tree,
Libmarpa then proceeds up the chain of parent objects.
Every time a child is destroyed, the
reference count of its parent is decreased by 1.
Every time the reference count of an object
is decreased by 1,
if that reference count is now zero,
that object is destroyed.
Libmarpa follows this chain of decrements
and destructions as required,
all the way back to the
base grammar, if necessary.

@end deftypefun

@node Registering semantics, Stepping through the valuator, Valuator reference counting, Value methods
@section Registering semantics

@deftypefun int marpa_v_symbol_is_valued ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid} )
@deftypefunx int marpa_v_symbol_is_valued_set ( @
    Marpa_Value @var{v}, @
    Marpa_Symbol_ID @var{symid}, @
    int @var{value} )
These methods, respectively, report and set to @var{value}
the valued status for symbol @var{symid}.
A valued status is either 1 or 0.
A valued status of 1 indicates that the symbol is valued.
A valued status of 0 indicates that the symbol is unvalued.

Return value:  On success, the valued status @strong{after}
the call.
On an attempt to set a locked valued status
to a value different from its current one, -1.
If @var{value} is not either 0 or 1,
or on other hard failure, -2.
@end deftypefun

@deftypefun int marpa_v_rule_is_valued ( @
    Marpa_Value @var{v}, @
    Marpa_Rule_ID @var{rule_id} )
@deftypefunx int marpa_v_rule_is_valued_set ( @
    Marpa_Value @var{v}, @
    Marpa_Rule_ID @var{rule_id}, @
    int @var{value} )
These methods, respectively, report and set to @var{value}
the valued status
for the LHS symbol of rule @var{rule_id}.
A valued status is either 1 or 0.
A valued status of 1 indicates that the symbol is valued.
A valued status of 0 indicates that the symbol is unvalued.

Rules have no valued status of their own.
The valued status of a rule
is always that of its LHS symbol.
These methods are conveniences -- they
save the application the trouble of looking
up the rule's LHS.

Return value:  On success, the valued status of the
rule @var{rule_id}'s LHS symbol @strong{after}
the call.
On an attempt to set a locked valued status
to a value different from its current one, -1.
If @var{value} is not either 0 or 1,
or on other hard failure, -2.
@end deftypefun

@node Stepping through the valuator, Valuator steps by type, Registering semantics, Value methods
@section Stepping through the valuator

@deftypefun Marpa_Step_Type marpa_v_step ( @
    Marpa_Value @var{v})
This method ``steps through'' the valuator.
The return value is a @code{Marpa_Step_Type},
a integer which indicates the type of step.
How the application is expected to act on
each step is described below.

Return value:  On success, the type of the step
to be performed.
On soft failure, @code{MARPA_STEP_INACTIVE}.
On other failure, -2.
@end deftypefun

@node Valuator steps by type, Step accessors, Stepping through the valuator, Value methods
@section Valuator steps by type

Stack locations are non-negative integers
The bottom of the stack is location 0.
In moving from the bottom of the stack to the top,
the numbers increase.
Stack location @var{X} is said to be ``greater'' 
than stack location @var{Y} if stack location
@var{X} is closer to the top of stack than location @var{Y},
and therefore stack locations are considered greater or
lesser if the integers that represent them are
greater or lesser.

@deftypevr Macro Marpa_Step_Type MARPA_STEP_RULE
The semantics of a rule should be performed.
The application can find the value of the rule's
children in the stack locations from
@code{marpa_v_arg_0(v)}
to @code{marpa_v_arg_n(v)}.
The semantics for the rule whose ID is
@code{marpa_v_rule(v)} should be executed
on these child values,
and the result placed in
@code{marpa_v_result(v)}.
The stack location of
@code{marpa_v_result(v)} is guaranteed to
be equal to 
to @code{marpa_v_arg_n(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_TOKEN
The semantics of a non-null token should be performed.
The value of the token whose ID is
@code{marpa_v_token(v)} should be
placed in
stack location @code{marpa_v_result(v)}.
Its value will be in
@code{marpa_v_token_value(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_NULLING_SYMBOL
The semantics for a nulling symbol should be performed.
The ID of the symbol is
@code{marpa_v_symbol(v)} and its value should
be placed in
stack location @code{marpa_v_result(v)}.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_INACTIVE
The valuator has gone through all of its steps
and is now inactive.
The value of the parse will be in stack location 0.

Because of unvalued symbols,
it is quite possible for valuator to immediately
became inactive -- @code{MARPA_STEP_INACTIVE} could
be the first and last step.
For similar reasons, the application
may need, on its own initiative,
to initialize the stack
to ensure there is a stack with a location 0 --
there will not necessarily be a valuator step that
prompts to do so.
@end deftypevr

@deftypevr Macro Marpa_Step_Type MARPA_STEP_INTERNAL1
@deftypevrx Macro Marpa_Step_Type MARPA_STEP_INTERNAL2
@deftypevrx Macro Marpa_Step_Type MARPA_STEP_TRACE
These step types are reserved for internal purposes.
@end deftypevr

@node Step accessors,  , Valuator steps by type, Value methods
@section Step accessors

Step accessors are implemented as macros.  They always succeed.

@deftypefn {Macro} Marpa_Symbol_ID marpa_v_token (Marpa_Value @var{v})
Return value: Returns the ID of the token
for the @code{MARPA_STEP_TOKEN} step.
@end deftypefn

@deftypefn {Macro} Marpa_Symbol_ID marpa_v_symbol (Marpa_Value @var{v})
Return value: Returns the ID of the symbol
for the @code{MARPA_STEP_NULLING_SYMBOL} step.
The value is always the same as that for the @code{marpa_v_token()}
macro.
@end deftypefn

@deftypefn {Macro} void* marpa_v_token_value (Marpa_Value @var{v})
Return value: Returns the integer which is (or represents)
the value of the token for the
@code{MARPA_STEP_TOKEN} step.
@end deftypefn

@deftypefn {Macro} Marpa_Rule_ID marpa_v_rule (Marpa_Value @var{v})
Return value: Returns the ID of the rule
token for the
@code{MARPA_STEP_RULE} step.
@end deftypefn

@deftypefn {Macro} int marpa_v_result (Marpa_Value @var{v})
Return the stack location where the result of the semantics
should be placed.
@end deftypefn

@deftypefn {Macro} int marpa_v_arg_0 (Marpa_Value @var{v})
For a @code{MARPA_STEP_RULE} step,
returns the stack location where the value of first child
can be found.
The value is always the same as that for the @code{marpa_v_result()}
macro.
@end deftypefn

@deftypefn {Macro} int marpa_v_arg_n (Marpa_Value @var{v})
For a @code{MARPA_STEP_RULE} step,
returns the stack location where the value of the last child
can be found.
@end deftypefn

@node Events, Error macros and code, Value methods, Top
@chapter Events

@menu
* Event codes::                 Event codes.
@end menu

@node Event codes,  , Events, Events
@section Event codes

@deftypevr Macro int MARPA_EVENT_NONE
Applications should never see this event.
Suggested message: "No event"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EXHAUSTED
The event value is undefined.
Suggested message: "Recognizer is exhausted"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_EARLEY_ITEM_THRESHOLD
The event value is undefined.
Suggested message: "Too many Earley items"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_LOOP_RULES
A rule is part of a cycle.
Cycles are pathological cases of recursion,
in which the same symbol string derives itself
a potentially infinite number of times.
Nonetheless, Marpa parses in the presence of these,
and it is up to the application to treat these
as fatal errors,
something most of them will wish to do.
The value of the event is the count of loop rules.
Suggested message: "Grammar contains a infinite loop"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_COUNTED_NULLABLE
A nullable is either the separator
for, or the right hand side of a sequence.
The value of the event is the ID of the symbol.
Suggested message: "This symbol is a counted nullable"
@end deftypevr

@deftypevr Macro int MARPA_EVENT_NULLING_TERMINAL
A nulling symbol is also a terminal.
The value of the event is the ID of the symbol.
Suggested message: "This symbol is a nulling terminal"
@end deftypevr

@node Error macros and code, Design considerations, Events, Top
@chapter Error macros and code

@menu
* Methods::                     
* Error Macros::                
* Error Codes::                 
@end menu

@node Methods, Error Macros, Error macros and code, Error macros and code
@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
When a method fails,
this method allows the application to read
the error code.
@var{p_error_string} is reserved for use by
the internals.
Applications should set it to @code{NULL}.

Return value: The last error code from a Libmarpa method.
Always succeeds.
@end deftypefun

@deftypefun Marpa_Error_Code marpa_r_error @
    (Marpa_Recognizer @var{r}, @
    const char** @var{p_error_string})
All errors are tracked in the grammar object.
This method is a convenience wrapper for @code{marpa_g_error()}.
@var{p_error_string} is reserved for use by
the internals.
Applications should set it to @code{NULL}.

Return value: The last error code from a Libmarpa method.
Always succeeds.
@end deftypefun

@node Error Macros, Error Codes, Methods, Error macros and code
@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@node Error Codes,  , Error Macros, Error macros and code
@section Error Codes

@deftypevr Macro int MARPA_ERR_NONE
No error condition.
The error code is initialized to this value.
An application should never see this value,
because it should examine the error code
only when a hard failure has been indicated,
in which case the error code will have set
to another value.

Methods which do not result in a hard failure
may reset the error code to @code{MARPA_ERR_NONE}
or leave it at its current value.
Which of the two a method does is currently
unspecified,
although the current implementation,
for efficiency and simplicity,
will usually leave the error code as it
found it.
Suggested message: "No error"
@end deftypevr

@deftypevr Macro int MARPA_ERR_AHFA_IX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_AHFA_IX_OOB
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDID_NOT_IN_OR
@end deftypevr
@deftypevr Macro int MARPA_ERR_ANDIX_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_BAD_SEPARATOR
@end deftypevr
@deftypevr Macro int MARPA_ERR_BOCAGE_ITERATION_EXHAUSTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol was found,
that is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
Questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in Libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule"
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
The "development" errors is for use during
Libmarpa's development,
while it is not yet clear how precisely
to classify every error condition.
The error string is a
short 7-bit ASCII error string
which describes the error.
Classifying an error as "development"
is a temporary measure,
taken until the error can be more
precisely defined and classed.
Suggested message: "Development error, see string"
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_AND_NODE
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule"
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
Libmarpa allows a maximum number of earley
items per Earley set.
This error code indicates that limit was
exceeded.
Note that this limit is different from
the optional earley item
warning threshold, which can be set
by the application.
Exceeding the warning threshold causes
a Libmarpa event, which the application
is free to treat as a hard or soft error.
Suggested message: "Maximum number of earley items exceeded"

Most likely, memory will run out for
other reasons long before this error can
occur.
The maximum earley item count for the
purposes of this error code
is over a billion.
As a contrast, a reasonable setting for the
warning threshold,
even when exceeding the threshold is
treated as a fatal error,
will usually be well under 1000.
If this error code ever does occur,
it is almost certainly both a hard and a
fatal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_ID_INVALID
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
Internal errors are errors which
"should not happen".
They could result when the calling program
overwrites Libmarpa's internal data.
They may also indicate a bug in Libmarpa.
An internal error will usually be a hard error.
Suggested message: "Internal error"
@end deftypevr

@deftypevr Macro int MARPA_ERR_INVALID_AHFA_ID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_AIMID
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_BOOLEAN
A function was called which takes a boolean argument,
one which must be either 0 or 1,
and that argument has some other value.
Suggested message: "Argument is not boolean"
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_ES_ORDINAL
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_IRLID
A method was called with an invalid internal rule ID.
Suggested message: "No IRL with that ID exists"
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_ISYID
A method was called with an invalid internal symbol ID.
Suggested message: "No ISY with that ID exists"
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_START_SYM
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_SYMID
After development, this error code should no longer
be used and should be deleted.
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_XRLID
A method was called with an invalid external rule ID.
Suggested message: "No rule with that ID exists"
@end deftypevr
@deftypevr Macro int MARPA_ERR_INVALID_XSYID
A method was called with an invalid external symbol ID.
Suggested message: "No symbol with that ID exists"
@end deftypevr

@deftypevr Macro int MARPA_ERR_MAJOR_VERSION_MISMATCH
There was a mismatch in the major version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr
@deftypevr Macro int MARPA_ERR_MICRO_VERSION_MISMATCH
There was a mismatch in the micro version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr
@deftypevr Macro int MARPA_ERR_MINOR_VERSION_MISMATCH
There was a mismatch in the minor version number
between the requested version
of libmarpa, and the actual one.
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOOKID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_PRECOMPUTED
@end deftypevr

@deftypevr Macro int MARPA_ERR_NOT_TRACING_COMPLETION_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_LEO_LINKS
@end deftypevr
@deftypevr Macro int MARPA_ERR_NOT_TRACING_TOKEN_LINKS
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_AND_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_OR_NODES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYM
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol"
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_TRACE_ES
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_PIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_EIM
@end deftypevr
@deftypevr Macro int MARPA_ERR_NO_TRACE_SRCL
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULLING_TERMINAL
Marpa does not allow a symbol to be both nulling
and a terminal.
Suggested message: "A symbol is both terminal and nulling"
@end deftypevr

@deftypevr Macro int MARPA_ERR_ORID_NEGATIVE
@end deftypevr
@deftypevr Macro int MARPA_ERR_OR_ALREADY_ORDERED
@end deftypevr
@deftypevr Macro int MARPA_ERR_ORDER_FROZEN
The Marpa order object has been frozen.
Multiple tree iterators can share a Marpa order object,
but that order object is @dfn{frozen} after the first tree
iterator is created from it.
If a Marpa order object is @dfn{frozen}, it cannot be
changed.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
@end deftypevr

@deftypevr Macro int MARPA_ERR_PARSE_EXHAUSTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_PARSE_TOO_LONG
@end deftypevr
@deftypevr Macro int MARPA_ERR_PIM_IS_NOT_LIM
@end deftypevr

@deftypevr Macro int MARPA_ERR_POINTER_ARG_NULL
In a method which takes pointers as arguments,
one of the pointer arguments is @code{NULL},
in a case where that is not allowed.
One such method is@ @code{marpa_r_progress_item()}.
Suggested message: "An argument is null when it should not be"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed"
@end deftypevr

@deftypevr Macro int MARPA_ERR_PROGRESS_REPORT_NOT_STARTED
No recognizer progress report is currently active,
and an action has been attempted which
is inconsistent with that.
One such action would be a
@code{marpa_r_progress_item()} call.
Suggested message: "No progress report has been started"
@end deftypevr

@deftypevr Macro int MARPA_ERR_RECCE_NOT_ACCEPTING_INPUT
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_NOT_STARTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_RECCE_STARTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_RHS_TOO_LONG
@end deftypevr

@deftypevr Macro int MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE
The LHS of a
sequence rule cannot be the LHS of any other rule,
whether a sequence rule or a BNF rule.
An attempt was made to violate this restriction.
Suggested message: "LHS of sequence rule would not be unique"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_NONE
The link source type is 'none'
in a context where that is not allowed.
Suggested message: "A source type of 'none' is not allowed here"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_TOKEN
The link source type is 'token'
in a context where that is not allowed.
Suggested message: "Token source type is not allowed here"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_COMPLETION
The link source type is 'completion'
in a context where that is not allowed.
Suggested message: "Completion source type is not allowed here"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_LEO
The link source type is 'Leo'
in a context where that is not allowed.
Suggested message: "Leo source type is not allowed here"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_AMBIGUOUS
The link source type is ambiguous
in a context where that is not allowed.
Suggested message: "Ambiguous source type is not allowed here"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SOURCE_TYPE_IS_UNKNOWN
The link source type is not known.
Suggested message: "The source type is unknown"
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule"
@end deftypevr

@deftypevr Macro int MARPA_ERR_SYMBOL_VALUED_CONFLICT
An unvalued symbol may take on any value,
and therefore a symbol which is unvalued at some points
cannot safely to be used to contain a value at
others.
This error indicates that such an unsafe use is
being attempted.
Suggested message: "Symbol is treated both as valued and unvalued"
@end deftypevr

@deftypevr Macro int MARPA_ERR_TOKEN_IS_NOT_TERMINAL
@end deftypevr
@deftypevr Macro int MARPA_ERR_TOKEN_LENGTH_LE_ZERO
@end deftypevr
@deftypevr Macro int MARPA_ERR_TOKEN_TOO_LONG
@end deftypevr
@deftypevr Macro int MARPA_ERR_TREE_EXHAUSTED
@end deftypevr
@deftypevr Macro int MARPA_ERR_TREE_PAUSED
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNKNOWN
The cause of the error could not be determined.
This usually indicates a problem in the error handling
logic itself.
This will usually be a hard error.
Suggested message: "Unknown error"
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol"
@end deftypevr

@deftypevr Macro int MARPA_ERR_VALUATOR_INACTIVE
The valuator is inactive in a context where that
should not be the case.
Suggested message: "Valuator inactive"
@end deftypevr

@node Design considerations, Things To Do, Error macros and code, Top
@chapter Design considerations

This section details some of the design choices
in Libmarpa.

@menu
* Why so many time objects::    
* Design of numbered objects::  
@end menu

@node Why so many time objects, Design of numbered objects, Design considerations, Design considerations
@section Why so many time objects?

Readers accustomed to other appraoches to parsing,
particular those in fashion at this writing,
may wonder on the number of time objects
in the Marpa architecture.
Several of Marpa's time objects (bocages,
orderings and trees) are required
because Marpa allows,
and offers powerful tools for dealing with,
ambigious grammars.

It may seem, then, that users of unambiguous grammars,
are paying a considerable price in time effiency
for the ability to parse
ambiguous ones.
This is not the case.
In the trivial case, the cost of the orderings
object is a single, very brief, subroutine call.

Bocage objects come at minimal cost,
because the same pass which creates the bocage
also deals with other issues which are of major
significance even for unambiguous parses.
The same pass which creates the bocage
enables Marpa to do both left-
and right-recursion in linear time.

Tree objects come at mininal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal, so that the valuation time object
has very litle to do -- it just steps through the sequence.

But what about the many passes over the data this requires?
Marpa is an aggressively multi-pass algorithm.
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it.
Marpa is @math{O(n)} for LR-regular grammars,
both in theory and in implementation,
because Marpa regularly substitutes
two fast @math{O(n)} passes for a single
@math{O(n log n)} pass.

@menu
* Why ordering objects?::       
@end menu

@node Why ordering objects?,  , Why so many time objects, Why so many time objects
@subsection Why ordering objects?

Of the various objects, the best
case for elimination is of the
ordering object.
In many cases, the ordering is trivial.
Either the parse is unambiguous, or the
application does not care about the order in
which parses are returned.

But while it would be easy to add an option
to bypass creation of an ordering object,
there is little to be gained from it.
When the ordering is trivial,
its overhead is very small --
essentially a handful of subroutine calls.
Many orderings accomplish nothing,
but these cost next to nothing.

@node Design of numbered objects,  , Why so many time objects, Design considerations
@section Numbered objects

As the name suggests,
the choice was made to implement
numbered objects and not as
pointers.
Integers can be easily and safely checked for validity,
while pointer cannot.

There are efficiency tradeoffs between pointers and
integers but they are complications and go both ways.
Pointers can be faster, but integers can be used
as indexes into more than one data structure.
Which is actually faster depends on the design.
Integers allow for a more flexible design,
so that once the choice is settled on,
careful programming can make them a win,
possibly a very big one.

The approach taken in Libmarpa was to settle
from the outset,
on integers as the implementation for numbered
objects and optimize on that basis.
In any case, the difference is speed on
modern architectures is
a small price to pay for
safe, portable validity checking.

@node Things To Do, Internal Interface, Design considerations, Top
@chapter Things to do

@itemize
@item
There should be an interface in the valuator that allows the user to
determine the start and end earlemes of a token.
@end itemize

@node Internal Interface,  , Things To Do, Top
@chapter Internal Interface

@menu
* Symbol internal methods::     
* Rule internals::              
* Grammar internals::           
* Recognizer internals::        
* Bocage internals::            
* Ordering internals::          
* Tree internals::              
* Valuator internals::          
@end menu

@node Symbol internal methods, Rule internals, Internal Interface, Internal Interface
@section Symbol internal methods

Internal methods are only for testing and development of libmarpa.
They are listed here (and sometimes described) for the convenience
of those working on libmarpa's internals.

Internal methods are subject to change.
Applications should not use internal methods.
Where a description exists and may be helpful,
it may be included below,
but all applications
should treat these methods as ``undocumented''.

@deftypefun int _marpa_g_rule_first_child_set ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
If the desired semantics is simply
to return the first child as the value
(not an uncommon case)
Marpa could implement that as a stack no-op.
This stub may become part of the external interface
at some point,
once I fully work out the implications
of "first child" semantics.
@end deftypefun

@deftypefun int _marpa_g_isy_is_start ( Marpa_Grammar @var{g}, @
    Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_is_nulling ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_is_lhs ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun Marpa_ISY_ID _marpa_g_xsy_nulling_isy ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_ISY_ID _marpa_g_xsy_isy ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_proper_alias ( @
  Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_symbol_null_alias ( @
  Marpa_Grammar @var{g}, @
  Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun int _marpa_g_symbol_is_semantic ( @
    Marpa_Grammar @var{g}, @
    Marpa_Symbol_ID @var{symid})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xsy ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_isy_lhs_xrl ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id})
@end deftypefun
@deftypefun int _marpa_g_isy_xrl_offset ( @
  Marpa_Grammar @var{g}, @
  Marpa_ISY_ID @var{isy_id} )
@end deftypefun

@node Rule internals, Grammar internals, Symbol internal methods, Internal Interface
@section Rule internals

@deftypefun int marpa_g_rule_is_keep_separation ( @
    Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
This function does nothing but return an undocumented flag.
At some point,
I may optimize cases where separators are discarded,
in which case this flag will be used.
I may also remove this call entirely.
Return value:
Returns 1 if
the keep separation flag is set,
0 if not.
Returns 0 if
@var{rule_id} is not a sequence rule.
On hard failure, returns -2.
@end deftypefun

@deftypefun int _marpa_g_isy_count ( @
  Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_irl_count ( @
  Marpa_Grammar @var{g})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_lhs ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
Return value: On success, the LHS symbol of the IRL.
On failure, -2.
@end deftypefun

@deftypefun int _marpa_g_irl_length ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
The length of a IRL is the number of symbols on its RHS.

Return value: On success, the IRL length.
On failure, -2.
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_g_irl_rh_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id}, @
    int @var{ix})
The position in the IRL, @var{ix}, is zero-based.
If @var{ix} is greater than or equal the length of the
IRL, it is a soft failure.
This can be used in loops, to avoid having to determine
the IRL's length explicitly.

Return value: On success, the symbol in position @var{ix}
on the IRL's RHS.
If @var{ix} is greater than or equal to the length of
the IRL, -1.
On other failures, -2.
@end deftypefun
@deftypefun int _marpa_g_rule_is_used (Marpa_Grammar @var{g}, @
    Marpa_Rule_ID @var{rule_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_lhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_irl_is_virtual_rhs (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun @code{unsigned int} _marpa_g_virtual_start (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun @code{unsigned int} _marpa_g_virtual_end (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_source_xrl (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun int _marpa_g_real_symbol_count (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_irl_semantic_equivalent (Marpa_Grammar @var{g}, @
    Marpa_IRL_ID @var{irl_id})
@end deftypefun

@node Grammar internals, Recognizer internals, Rule internals, Internal Interface
@section Grammar internal methods

The methods in this section are accessors for Libmarpa's
AHFA items and states.
Their use requires familiarity with
Marpa's internals, as described in
@cite{Marpa: The Program}.

@deftypefun int _marpa_g_AHFA_item_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun Marpa_Rule_ID _marpa_g_AHFA_item_irl (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_position (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_item_postdot (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_item_sort_key (Marpa_Grammar @var{g}, @
    Marpa_AHFA_Item_ID @var{item_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_count (Marpa_Grammar @var{g})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_item_count (Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_AHFA_Item_ID _marpa_g_AHFA_state_item (Marpa_Grammar @var{g}, @
     Marpa_AHFA_State_ID @var{AHFA_state_id}, @
 int @var{item_ix})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_is_predict (Marpa_Grammar @var{g}, @
 Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_g_AHFA_state_leo_lhs_symbol ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id})
@end deftypefun
@deftypefun int _marpa_g_AHFA_state_transitions ( @
    Marpa_Grammar @var{g}, @
    Marpa_AHFA_State_ID @var{AHFA_state_id}, @
    int *@var{buffer}, @
    int @var{buffer_size} @
    )
@end deftypefun
@deftypefun Marpa_AHFA_State_ID _marpa_g_AHFA_state_empty_transition ( @
    Marpa_Grammar @var{g}, @
     Marpa_AHFA_Item_ID @var{AHFA_item_id})
@end deftypefun

@node Recognizer internals, Bocage internals, Grammar internals, Internal Interface
@section Recognizer internals


@deftypefun int _marpa_r_is_use_leo (Marpa_Recognizer @var{r})
@deftypefunx int _marpa_r_is_use_leo_set ( Marpa_Recognizer @var{r}, @
    int @var{value})
Reports and sets, respectively, the ``use Leo'' flag.
This flag controls whether Joop Leo's method for fast parsing
of right recursion is used.
By default, this value is 1 and Leo parsing is in use.
This default should be used except for testing, debugging
and development.
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_trace_earley_set (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun int _marpa_r_earley_set_size (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme _marpa_r_earley_set_trace (Marpa_Recognizer r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_earley_item_trace (Marpa_Recognizer r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_earley_item_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_leo_predecessor_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_leo_base_origin (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_leo_base_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_leo_expansion_ahfa (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_postdot_symbol_trace (Marpa_Recognizer r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_postdot_item_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_postdot_item_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_token_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_completion_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_first_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_next_leo_link_trace (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID _marpa_r_source_predecessor_state (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_source_token (Marpa_Recognizer r, int *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID _marpa_r_source_leo_transition_symbol (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID _marpa_r_source_middle (Marpa_Recognizer @var{r})
@end deftypefun

@node Bocage internals, Ordering internals, Recognizer internals, Internal Interface
@section Bocage internals

@deftypefun int _marpa_b_and_node_count ( @
    Marpa_Bocage @var{b})
@end deftypefun
@deftypefun int _marpa_b_and_node_parent ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_predecessor ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_cause ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun int _marpa_b_and_node_symbol ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id})
@end deftypefun
@deftypefun Marpa_Symbol_ID _marpa_b_and_node_token ( @
    Marpa_Bocage @var{b}, @
    Marpa_And_Node_ID @var{and_node_id}, @
    int* @var{value_p})

Returns the data for the token of the and-node.
The symbol id is the return value,
and the token value is placed
in the location pointed
to by @var{value_p}, if that is non-null.
If @var{and_node_id} is not the ID of an and-node
whose cause is a token,
returns -1,
without changing @var{value_p}.
On hard failure, returns -2 without changing
@var{value_p}.

There is no function to simply return the token value --
because of the need to indicate errors, it is just as
easy to return the symbol ID as well.
@end deftypefun
@deftypefun Marpa_Or_Node_ID _marpa_b_top_or_node ( @
    Marpa_Bocage @var{b})

Return the ID of the top or-node.
@end deftypefun
@deftypefun int _marpa_b_or_node_set ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})

Return the ordinal of the current (final) Earley set of
the or-node.
@end deftypefun
@deftypefun int _marpa_b_or_node_origin ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun Marpa_IRL_ID _marpa_b_or_node_irl ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_position ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_first_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_last_and ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun
@deftypefun int _marpa_b_or_node_and_count ( @
    Marpa_Bocage @var{b}, @
    Marpa_Or_Node_ID @var{or_node_id})
@end deftypefun

@node Ordering internals, Tree internals, Bocage internals, Internal Interface
@section Ordering internals

@deftypefun int _marpa_o_and_order_set ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    Marpa_And_Node_ID* @var{and_node_ids}, @
    int @var{length})
@end deftypefun

@deftypefun Marpa_And_Node_ID _marpa_o_and_order_get ( @
    Marpa_Order @var{o}, @
    Marpa_Or_Node_ID @var{or_node_id}, @
    int @var{ix})
@end deftypefun

@node Tree internals, Valuator internals, Ordering internals, Internal Interface
@section Tree internals

In Marpa, a nook is any node of a parse tree.
The usual term is "node",
but within Marpa,
the word "node" is already heavily overloaded.
So what most texts call "tree nodes" are here
called "nooks".
"Nook" can be thought of as a pun on both
"node" and "fork".

@deftypefun int _marpa_t_size ( @
	Marpa_Tree @var{t})
Return the size of the parse tree.
This is the number of nooks in its stack.
If there is a serious error,
or if the tree is uninitialized, return -2.
If the tree is exhausted, return -1.
@end deftypefun

@deftypefun Marpa_Or_Node_ID _marpa_t_nook_or_node ( @
    Marpa_Tree @var{t}, @
    Marpa_Nook_ID @var{nook_id})

Return the ID of the or-node for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_choice ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the current choice for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_parent ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the parent nook's ID for @var{nook_id}.
As with the other nook trace functions,
-1 is returned if @var{nook_id} is not the ID of
a nook on the stack,
but -1 can also be a valid value.
If that's an issue, the @var{nook_id} needs
to be checked with one of the trace functions
where -1 is never a valid value ---
for example, @code{_marpa_t_nook_or_node}.
@end deftypefun

@deftypefun int _marpa_t_nook_cause_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the cause-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_predecessor_is_ready ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the predecessor-is-ready bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_cause ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-cause bit for @var{nook_id}.
@end deftypefun

@deftypefun int _marpa_t_nook_is_predecessor ( @
	Marpa_Tree @var{t}, @
	Marpa_Nook_ID @var{nook_id} @
	)

Return the is-predecessor bit for @var{nook_id}.
@end deftypefun

@node Valuator internals,  , Tree internals, Internal Interface
@section Valuator internals

@deftypefun int _marpa_v_trace ( @
    Marpa_Value @var{v}, @
    int @var{flag})
@end deftypefun

@deftypefun Marpa_Nook_ID _marpa_v_nook ( @
    Marpa_Value @var{v})
@end deftypefun

@bye
