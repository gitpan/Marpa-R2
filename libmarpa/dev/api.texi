\input texinfo @c -*-texinfo-*- 
@c %**start of header 
@setfilename api.info 
@settitle libmarpa 0.0.0
@c %**end of header 
@copying 
This manual is for libmarpa, version 0.0.0. 
Copyright @copyright{} 2011 Jeffrey Kegler.
@quotation 
Permission is granted to copy, distribute and/or modify this document 
under the terms of the GNU Free Documentation License, Version 1.2 or 
any later version published by the Free Software Foundation;
@end quotation 
@end copying 
@titlepage 
@title libmarpa
@author Jeffrey Kegler
@c The following two commands 
@c start the copyright page. 
@page 
@vskip 0pt plus 1filll 
@insertcopying

Published by Jeffrey Kegler
@end titlepage 
@c So the toc is printed at the start. 
@contents 
@ifnottex 
@node Top 
@top title 
This manual is for libmarpa, version 0.0.0. 
@end ifnottex 
@menu 
* About this document:: About this document
* About libmarpa:: About libmarpa
* Grammars:: Grammar objects
* Recognizers:: Recognizer objects
* Bocage:: Bocage objects
* Order:: Order objects
* Error handling:: Error handling
@end menu 

@node About this document
@chapter About this document

This document is intended as a reference manual
for a complex low-level tool.
The reader might compare it to the GNU C Language
manual, which makes no attempt to teach much of
the technical knowledge required to appreciate its
contents or, for that matter,
even the C language itself.

This document assumes the reader has read the documents
for one of libmarpa's upper layers.
I hope that will soon change,
but currently all of libmarpa's upper layers
are Perl distributions.
The most up-to-date Marpa upper layer is Marpa::R2.

This document also assumes an acquaintance
with parsing theory.
As a test of whether he needs to refresh
his knowledge before tackling
this document,
I hope the reader will find it helpful to
ask himself the
following list of questions.
@itemize @bullet
@item
What is a BNF rule?
@item
What is a Marpa sequence rule?
@item
As a reminder,
Marpa's sequence rules are implemented
as left recursions.
What does that mean?
@item
If you were given a Marpa sequence rule,
could you rewrite it in BNF?
@item
Would you know whether your rewrite was
left- or right-recursive?
@item
Could you change it from one to the other?
@end itemize
For a reader to be satisfied with the level of detail
in the following pages,
he probably should be able to answer all the questions
in the above list either off the top of his head,
or after a moment of thought.

On the encouraging side,
while BNF has been overshadowed
by regular expressions, and is now considered
an advanced skill,
BNF is in fact as easy (or easier) to learn
and manipulation than regular expressions.
If a reader who has learned how to use
one of the packages that extend
regular expressions,
he should have no trouble with BNF.

@node About libmarpa
@chapter About libmarpa
This is the reference manual for libmarpa.
libmarpa implements the Marpa parsing algorithm.
Marpa is my creation.
I named it
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
I depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.

libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces parse trees.
It also supports the ordering and evaluation of the parse
trees.

However, it is very low-level.
libmarpa, for example, has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for most applications.
A user will almost always want,
at a minimum,
names for the symbols and non-integer values for
tokens.
Typically, an application will use arrays to
translate libmarpa's integer IDs to strings or other
values as required.

libmarpa also does NOT implement most of the semantics.
libmarpa does have an evaluator, but it does NOT
manipulate the stack directly.
Instead, libmarpa,
based on its traversal of the parse tree,
passes step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved
involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.

While libmarpa passes instruction for stack manipulation,
it does not actually maintain a stack.
This leaves the upper layer in total control of the
stack and the values which are placed on it.

As example may make this clearer.
Suppose the evalution is at a place in the parse tree
where an addition is being performed.
libmarpa does not know that the operation
is an addition.
It will tell the application that rule number R
is to be applied to the arguments at stack locations
N and N+, and that the result is to placed in
stack location N.

In this system,
The application keeps track of the semantics for all
rules, so it looks up rule R and determines that it
is an addition.
The application can do this by using R as an index
into an array of callbacks, or by any other method
it chooses.
Let's assume a callback implements the semantics
for rule R.
libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations N and N+1 in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let's say, 753.
libmarpa has told the application that the result
belongs at location N in the stack,
so the application writes 752 to location N.

Since libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers; or objects which may be any
or all of these and more.

This technique
hides libmarpa's grammar rewrites from the application,
and is actually quite efficient.
libmarpa knows which rules are sequences
and optimizes stack manipulations based on this knowledge.
Many practical grammars use long sequences heavily,
and for these libmarpa the series of steps
suggest by libmarpa will be significantly faster than the standard 
stack evaluation algorithm in the textbooks.

To make it clear,
I am under no illusion that libmarpa's evaluator will be found
satisfactory even to most application programmers.
I certainly avoid using it directly.
It is intended to be used via an upper layer,
one which does know about semantics.

But, by isolating libmarpa from semantics, libmarpa avoids
imposing any arbitrary restrictions on the semantics used
with the Marpa algorithm.
To see the advantage suppose, as I expect will often be the case,
libmarpa is used as the basis
for a higher-level language which needs callbacks in that higher level language.
For generality, libmarpa would have to deal in C callback,
which wrapper the callbacks in the higher level language.
This is complex to code and inefficient,
but that is not its worst aspect.
The worst aspect happens when there is a programming error.
This error will occur inside libmarpa,
and inside code about which libmarpa can make no assumptions.

If all semantics are implemented in the application,
the application is in a much better position to prevent errors,
to catch them at runtime or
failing all else,
to successfully debug the logic.

@node Grammars
@chapter Grammars
@cindex grammars

@deftypefun const char* marpa_check_version @
    (unsigned int @var{required_major}, @
    unsigned int @var{required_minor}, @
    unsigned int @var{required_micro})

Checks that the GLib library in use is compatible with the
given version. Generally you would pass in the constants
#GLIB_MAJOR_VERSION, #GLIB_MINOR_VERSION, #GLIB_MICRO_VERSION
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of GLib the application or module was compiled
against.

Compatibility is defined by two things: first the version
of the running library is newer than the version
@var{required_major}.@var{required_minor}.@var{required_micro}.
Second
the running library must be binary compatible with the
version
@var{required_major}.@var{required_minor}.@var{required_micro}
(same major version.)

Return value: %NULL if the GLib library is compatible with the
  given version, or a string describing the version mismatch.
  The returned string is owned by GLib and must not be modified
  or freed.

@end deftypefun

@deftypefun void marpa_g_unref (Marpa_Grammar @var{g})
@end deftypefun

@deftypefun Marpa_Grammar marpa_g_ref (Marpa_Grammar @var{g})
@end deftypefun

@node Recognizers
@chapter Recognizer objects

@deftypefun Marpa_Recognizer marpa_r_ref (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun void marpa_r_unref (Marpa_Recognizer @var{r})
@end deftypefun

@deftypefun Marpa_Error_Code marpa_r_error @
    (const struct marpa_r* @var{r}, @
    const char** @var{p_error_string})
@end deftypefun

@deftypefun struct marpa_r* marpa_r_new ( struct marpa_g* @var{g} )
@end deftypefun

@deftypefun Marpa_Phase marpa_r_phase (struct marpa_r* @var{r})
@end deftypefun

@deftypefun guint marpa_r_current_earleme (struct marpa_r* @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_item_warning_threshold (struct marpa_r* @var{r})
@end deftypefun

@deftypefun gint marpa_r_earley_item_warning_threshold_set (struct marpa_r*@var{r}, gint @var{threshold})
@end deftypefun

@deftypefun guint marpa_r_furthest_earleme (struct marpa_r* @var{r})
@end deftypefun

@deftypefun gint marpa_r_terminals_expected (struct marpa_r* @var{r}, GArray* @var{result})
@end deftypefun

@deftypefun gboolean marpa_r_is_use_leo (struct marpa_r* @var{r})
@end deftypefun

@deftypefun gboolean marpa_r_is_use_leo_set ( struct marpa_r*@var{r}, gboolean @var{value})
@end deftypefun

@deftypefun gboolean marpa_r_is_exhausted (struct marpa_r* @var{r})
@end deftypefun

@deftypefun gint marpa_r_event (const struct marpa_r* @var{r}, struct marpa_g_event *@var{public_event}, gint @var{ix})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_trace_earley_set (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_latest_earley_set (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme (struct marpa_r* r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun gint marpa_r_earley_set_size (struct marpa_r *r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earley_set_trace (struct marpa_r *r, Marpa_Earley_Set_ID @var{set_id})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_earley_item_trace (struct marpa_r *r, Marpa_Earley_Item_ID @var{item_id})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_earley_item_origin (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_leo_predecessor_symbol (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_leo_base_origin (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_base_state (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_leo_expansion_ahfa (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_postdot_symbol_trace (struct marpa_r *r, Marpa_Symbol_ID @var{symid})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_postdot_item_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_postdot_item_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_postdot_item_symbol (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_token_link_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_token_link_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_completion_link_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_completion_link_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_first_leo_link_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_next_leo_link_trace (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_AHFA_State_ID marpa_r_source_predecessor_state (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_token (struct marpa_r *r, gpointer *@var{value_p})
@end deftypefun

@deftypefun Marpa_Symbol_ID marpa_r_source_leo_transition_symbol (struct marpa_r *@var{r})
@end deftypefun

@deftypefun Marpa_Earley_Set_ID marpa_r_source_middle (struct marpa_r* @var{r})
@end deftypefun

@deftypefun gboolean marpa_r_start_input (struct marpa_r *@var{r})
@end deftypefun

@deftypefun gboolean marpa_r_alternative (struct marpa_r *r, Marpa_Symbol_ID @var{token_id}, gpointer @var{value}, gint @var{length})
@end deftypefun

@deftypefun Marpa_Earleme marpa_r_earleme_complete (struct marpa_r* @var{r})
@end deftypefun

@node Bocage
@chapter Bocage objects

@deftypefun Marpa_Bocage marpa_b_new (Marpa_Recognizer @var{r}, @
    Marpa_Rule_ID @var{rule_id}, @
    Marpa_Earley_Set_ID @var{ordinal_arg})
@end deftypefun

@deftypefun Marpa_Bocage marpa_b_ref (Marpa_Bocage @var{b})
@end deftypefun

@deftypefun void marpa_b_unref (Marpa_Bocage @var{b})
@end deftypefun

@deftypefun Marpa_Grammar marpa_b_g (Marpa_Bocage @var{b})
@end deftypefun

@node Order
@chapter Order objects

@deftypefun gint marpa_o_and_order_set ( @
    Marpa_Recognizer r, @
    Marpa_Or_Node_ID or_node_id, @
    Marpa_And_Node_ID* and_node_ids, @
    gint length)
@end deftypefun

@deftypefun Marpa_And_Node_ID marpa_o_and_order_get ( @
    Marpa_Recognizer r, @
    Marpa_Or_Node_ID or_node_id, @
    gint ix)
@end deftypefun

@node Error handling
@chapter Error handling

@section Soft and hard errors

Soft errors are errors which may be a result of normal processing.
Soft errors often do not disrupt the flow of processing,
and applications typically do not treat soft errors
as fatal errors.
When a soft error is an interruption of normal processing,
the disruption is usually recoverable.

Hard errors are errors which are never the result of
normal processing.
They almost always disrupt the flow of processing.
Recovery from a hard error is usually not possible,
and an application will usually treat a hard error
as a fatal error.

The difference between hard and soft errors can
depend, to a certain extent,
on the application.
libmarpa has its own idea of what is a hard
and soft error but,
whenever possible,
it does not enforce this on the application.
An application is also free to treat a soft
error as a hard error.
And libmarpa makes
every attempt to allow an application to
reinterpret a hard error as a soft error.

@section Methods

@deftypefun Marpa_Error_Code marpa_g_error @
    ( Marpa_Grammar @var{g}, @
    const char** @var{p_error_string})
@end deftypefun

@section Error Macros

@deftypevr Macro int MARPA_ERRCODE_COUNT
The number of error codes.
@end deftypevr

@section Error Codes

@deftypevr Macro int MARPA_ERR_NONE
No error condition since the last time the
error code was reset or,
if there was no reset,
since grammar initialization.
Suggested message: "No error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_COUNTED_NULLABLE
A "counted" symbol is also a nullable symbol.
A "counted" symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting occurrences of it,
which is what sequence rules do for their RHS
symbols,
becomes very difficult.
All sorts of questions of definition and
problems of implementation arise.
At a minimum, such a sequence would be wildly
ambigious.

Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
Suggested message: "Nullable symbol on RHS of a sequence rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DEVELOPMENT
The "development" errors is for use during
libmarpa's development,
while it is not yet clear how precisely
to classify every error condition.
The error string is a
short 7-bit ASCII error string
which describes the error.
Classifying an error as "development"
is a temporary measure,
taken until the error can be more
precisely defined and classed.
Suggested message: "Development error, see string."
@end deftypevr

@deftypevr Macro int MARPA_ERR_DUPLICATE_RULE
This error indicates an attempt to add a rule which
is a duplicate of a rule already in the grammar.
Two rules are considered duplicates if

@itemize @bullet
@item
Both rules have the same left hand symbol.
@item
Both rules have the same right hand symbols in the same order.
@end itemize

This definition applies to sequence rules, as well as to ordinary rules. As a consequence, sequence rules can be considered duplicates even when they have different separators and/or different minimum counts.
Suggested message: "Duplicate rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_EIM_COUNT
libmarpa allows a maximum number of earley
items per Earley set.
This error code indicates that limit was
exceeded.
Note that this limit is different from
the optional earley item
warning threshold, which can be set
by the application.
Exceeding the warning threshold causes
a libmarpa event, which the application
is free to treat as a hard or soft error.
Suggested message: "Maximum number of earley items exceeded."

Most likely, memory will run out for
other reasons long before this error can
occur.
The maximum earley item count for the
purposes of this error code
is over a billion.
As a contrast, a reasonable setting for the
warning threshold,
even when exceeding the threshold is
treated as a fatal error,
will usually be well under 1000.
If this error code ever does occur,
it is almost certainly both a hard and a 
fatal error.
@end deftypevr

@deftypevr Macro int MARPA_ERR_INTERNAL
Internal errors are errors which
"should not happen".
They could result when the calling program
overwrites libmarpa's internal data.
They may also indicate a bug in libmarpa.
An internal error will usually be a hard error.
Suggested message: "Internal error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_LHS_IS_TERMINAL
By default,
and unlike most parsing algorithms,
libmarpa allow LHS terminals
-- symbols on the LHS side of a rule,
but which may also be terminals.
This behavior is configurable,
and if
the LHS terminals flag for a grammar is unset,
LHS terminals become illegal,
and cause this error.
Suggested message: "There is a LHS terminal in a grammar which has disallowed them."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NULL_RULE_UNMARKED_TERMINALS
Marpa allows all symbols to be terminals, even those on the LHS,
and this is the default.
But when there is an null rule in the grammar,
having lots of terminals is an efficiency hit.
For that reason, if a grammar has a null rule,
libmarpa requires the application to explictly
indicate which symbols are terminals,
and will not accept the default.

An application is still able to have as many terminals
as it wants,
including terminals on the LHS of rules.
The only requirement is the the user explicitly
set those symbols which are terminals.
Terminals may be explicitly marked on a per-symbol
basis.
The application can
also prevent this error by
unsetting the LHS terminals flag for a grammar.
Suggested message: "A grammar with null rules must mark its terminals."
@end deftypevr

@deftypevr Macro int MARPA_ERR_PRECOMPUTED
An attempt was made to use a precomputed grammar
in a way that is not allowed.
After a grammar is precomputed,
any changes to it that would invalidate
the precomputation
is not allowed.
Almost all changes to a grammar invalidate
the precomputations.
Suggested message: "This grammar is precomputed."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_PARSE
The application attempted to create a bocage
from a recognizer without a parse.
The application will often treat this as
a soft error.
Suggested message: "No parse."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_RULES
A grammar which has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
The precomputations are not defined
for grammar without rules,
in large part because it would be useless to do so.
Suggested message: "This grammar does not have any rules."
@end deftypevr

@deftypevr Macro int MARPA_ERR_NO_START_SYMBOL
The grammar has no start symbol,
and an attempt was made to perform an
operation which requires one.
For example, no grammar without a start
symbol can be precomputed.
Suggested message: "This grammar has no start symbol."
@end deftypevr

@deftypevr Macro int MARPA_ERR_START_NOT_LHS
The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Start symbol not on LHS of any rule."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNKNOWN
The cause of the error could not be determined.
This usually indicates a problem in the error handling
logic itself.
This will usually be a hard error.
Suggested message: "Unknown error."
@end deftypevr

@deftypevr Macro int MARPA_ERR_UNPRODUCTIVE_START
The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
Presumably, an error in writing the grammar.
Suggested message: "Unproductive start symbol."
@end deftypevr

@bye
