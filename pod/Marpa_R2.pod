# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2 - Release 2 of Marpa

=head1 Synopsis

=for Marpa::R2::Display
name: Landing page synopsis
normalize-whitespace: 1

    use Marpa::R2;

    my $grammar = Marpa::R2::Scanless::G->new(
        {   action_object  => 'My_Nodes',
            default_action => '::first',
            source         => \(<<'END_OF_SOURCE'),
    :start ::= Expression
    Expression ::= Term
    Term ::=
          Factor
        | Term '+' Term action => do_add
    Factor ::=
          Number
        | Factor '*' Factor action => do_multiply
          Number ~ digits
          digits ~ [\d]+
          :discard ~ whitespace
          whitespace ~ [\s]+
    END_OF_SOURCE
        }
    );

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );
    my $input = '42 * 1 + 7';
    $recce->read( \$input );

    my $value_ref = $recce->value;
    my $value = $value_ref ? ${$value_ref} : 'No Parse';

    sub My_Nodes::new { return {}; }

    sub My_Nodes::do_add {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 + $t2;
    }

    sub My_Nodes::do_multiply {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 * $t2;
    }

=for Marpa::R2::Display::End

=head1 Description

=head2 Overview

Marpa parses any language whose
grammar can be written in BNF.
That includes recursive grammars,
ambiguous grammars, infinitely ambiguous grammars and
grammars with useless or empty productions.
Marpa does both left- and right-recursion in linear time --
in fact if a grammar is in any class currently
in practical use, Marpa will parse it in linear time.

This document centers around a short tutorial
of the Scanless interface (SLIF),
the interface most suitable for beginner's and
for many advanced uses as well.


=head1 A simple calculator

The synopsis shows the code for a very simple calculator.
It handles only
addition and multiplication of integers.
The sections which follow explain, line by line, how it works.
The explanation will assume that the reader
understands BNF and the basics of grammars,
such as what a grammar's start symbol is.

=head2 Marpa::R2::Scanless::G::new

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $grammar = Marpa::R2::Scanless::G->new(
        {   action_object  => 'My_Nodes',
            default_action => '::first',
            source         => \(<<'END_OF_SOURCE'),
    :start ::= Expression
    Expression ::= Term
    Term ::=
          Factor
        | Term '+' Term action => do_add
    Factor ::=
          Number
        | Factor '*' Factor action => do_multiply
          Number ~ digits
          digits ~ [\d]+
          :discard ~ whitespace
          whitespace ~ [\s]+
    END_OF_SOURCE
        }
    );

=for Marpa::R2::Display::End

The code first creates a new SLIF grammar.
SLIF grammars are
L<C<Marpa::R2::Scanless:G>|Marpa::R2::Scanless::G> objects.
They are created
with the
L<Marpa::R2::Scanless:G::new|Marpa::R2::Scanless::G/"new">
constructor.
The arguments to
L<Marpa::R2::Scanless::G::new|Marpa::R2::Scanless::G/"new">
are references to
hashes of named arguments.
In the key/value pairs of these hashes,
the
hash key
is the
name of the argument,
and the
hash value
is the
value of the named argument.

In what follows, we will look at all the arguments of
this call to the 
L<Marpa::R2::Scanless:G::new|Marpa::R2::Scanless::G/"new">
method in detail.
First let's look at the C<source> argument.
Its value is a reference to a string in the
L<SLIF's domain-specific language|Marpa::R2::Scanless:DSL>
(DSL).
In this example, the DSL consists of several rules
and pseudo-rules.

=head2 The start pseudo-rule

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    :start ::= Expression

=for Marpa::R2::Display::End

The C<start> pseudo-rule is is required.
Its right hand side (RHS) is the grammar's start symbol.

=head2 A G1 rule

Next follows a G1, or structural rule.
Structural rules are the kinds of rules typically seen in BNF --
they describe the symbols which provide the structure of the grammar,
but leave out details of whitespace.

The SLIF also handles the lexical details in this example,
but it does it via G0 rules,
which we will see shortly.

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    Expression ::= Term

=for Marpa::R2::Display::End

As is normal for BNF rules, this rule consists of 
a left hand side symbol ("C<Expression>"),
the BNF operator ("C<::=>")
and a series of right hand side (RHS) symbols.
There is always exactly one left hand side (LHS)
symbol.
There may be any number of RHS symbols.
In the case of an empty rule,
the number of RHS symbols would be zero.
In this rule, there is one RHS
symbol, "C<Term>".

The BNF operator ("C<::=>") is what makes this rule
a G1 (structural) rule.
Later we will see lexical rules, which will use
the match operator ("C<~>").

=head2 More complicated G1 rules

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    Term ::=
          Factor
        | Term '+' Term action => do_add

=for Marpa::R2::Display::End

This rule says that a C<Term> may be one of two
alternatives: either a C<Factor>
or two C<Term>'s separated by an addition operator.
The second alternative has an
C<action> adverb associated with it.
We'll explain its purpose shortly.

Immediately following is another G1 rule defining
a C<Factor>.  It is very similar in form
to the one for C<Term>.

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    Factor ::=
          Number
        | Factor '*' Factor action => do_multiply

=for Marpa::R2::Display::End

=head2 G0 rules

The structural rules define the high-level structure of the grammar,
and ignore details of whitespace, comments, etc.
Now we look at how the low-level, lexical issues are handled.
This very simple calculator language does not allow comments,
but it does define whitespace.

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

          :discard ~ whitespace
          whitespace ~ [\s]+

=for Marpa::R2::Display::End

The C<:discard> rule is a pseudo-rule, which tells Marpa to use whatever
it matches to separate G1 symbols,
but otherwise to ignore it -- to "discard" it.
C<whitespace> is defined in the next rule as a sequence of one or more spaces.

Note the match operator ("C<~>") in the rule defining whitespace.
It tells Marpa that this rule is lexical and
should be interpreted exactly as written, character
by character.

The C<whitespace> rule is a special kind of rule in two respects.
First, its RHS is following by a quanitifer ("C<+>"), which makes it
a sequence rule.
Aside from the quantifier,
sequence rules may only have a single symbol or character class on their RHS.
The plus quanitifer ("C<+>") means a sequence of one or more items.
The star quanitifer ("C<*>") is also allowed, and it indicates a sequence of
zero or more items.

The whitespace items are defined by a character class: C<[\s]>.
Marpa supports the same character classes, and the same character class syntax,
as Perl does.

The next pair of G0 rules define the C<Number> symbol

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

          Number ~ digits
          digits ~ [\d]+

=for Marpa::R2::Display::End

The above two rules say that a C<Number> is a sequence of one or more digits.
C<Number> is a lexeme -- a G1 symbol which is defined and recognized at the lexical
(G0) level.
In this example, there are three other lexemes:
C<whitespace>, and the addition and multiplication operators.

We've already looked at
the C<whitespace> lexeme, which will be discarded without being seen by G1.
The addition and multiplication operators were defined with single quoted strings
in the G1 rules.  As a reminder, here's the rule for C<Term> again:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    Term ::=
          Factor
        | Term '+' Term action => do_add

=for Marpa::R2::Display::End

In the above rule, the single-quoted string C<'+'> implicitly defines a G0 lexeme.
Something similar happens with the C<'*'> string in the rule for a C<Factor>.

The SLIF's lexer mostly "does what you mean".
While the input is being read, it looks for all lexemes defined in the DSL.
The search is a longest tokens match, if mulitple tokens could match,
the longest match is the winner.
Marpa tolerates ambiguity,
so one feature special to Marpa is that it is a longest B<tokens> match --
if more than one token is longest, all of them are considered in the parse.
The logic of SLIF lexing is described with more precision in the
L<SLIF overview document|Marpa::R2::Scanless>.

=head2 Marpa::R2::Scanless::R::new

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

=for Marpa::R2::Display::End

C<Marpa::R2::Scanless::R::new> creates a new SLIF recognizer.
Its arguments are references to hashes of named arguments.
In this example the only named argument is
the required argument: "C<grammar>".
The value of the
C<grammar>
named argument must be a Marpa SLIF
grammar.

=head2 Marpa::R2::Scanless::R::read

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $input = '42 * 1 + 7';
    $recce->read( \$input );

=for Marpa::R2::Display::End

To parse a string,
we use 
the C<Marpa::R2::Scanless::R::read()> method.
In its simplest form,
as here,
the C<Marpa::R2::Scanless::R::read()> takes a reference
to a string containing the input stream as its argument.

=head2 Marpa::R2::Scanless::R::value

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $value_ref = $recce->value;
    my $value = $value_ref ? ${$value_ref} : 'No Parse';

=for Marpa::R2::Display::End

The C<Marpa::R2::Scanless::R::value()> method returns
a reference to the parse result's value,
if there was a parse result.
If there was no parse result,
C<Marpa::R2::Scanless::R::value()>
returns
C<undef>.

We have yet to describe how the Marpa SLIF computes the value
of a parse.
In fact,
up to this point,
we have been skipping everything that had to do
with semantics.
Now it is time to go back to those features.

=head2 Semantics

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

            action_object  => 'My_Nodes',
            default_action => '::first',

=for Marpa::R2::Display::End

The C<action_object> named argument specifies the package where the semantics closures are found,
in this example, the C<My_Nodes> package.
The C<default_action> named argument indicates the action to be used
when nothing else specifies the semantics for a closure.
In this example the default semantics are a "reserved action" named "C<::first>".
(The initial double colon indicates a reserved action.)
The "C<::first>" action indicates that the value of a rule is the value
of its first child.

The semantics for a RHS alternative are specified with the
C<action> adverb.
We've already seen the C<action> adverb twice, but skipped over it.
Here it is again, in context:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    Term ::=
          Factor
        | Term '+' Term action => do_add
    Factor ::=
          Number
        | Factor '*' Factor action => do_multiply

=for Marpa::R2::Display::End

The action for the second RHS alternative defining C<Term> is C<do_add>,
and the action for the second RHS alternative defining C<Factor> is C<do_multiply>.
To implement these actions, we need to "resolve" their names --
map the action names into 
the Perl closures which actually carry out the semantics.

The C<actions_object> specified the package where we can find the actions:
"C<My_Nodes>".
So, to resolve the C<do_multiply> action,
Marpa looks for a closure whose fully qualified name is C<My_Nodes::do_multiply>,
which it finds:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    sub My_Nodes::do_multiply {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 * $t2;
    }

=for Marpa::R2::Display::End

The C<do_add> action is resolved
to a Perl semantic closure
in much the same way:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    sub My_Nodes::do_add {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 + $t2;
    }

=for Marpa::R2::Display::End

The Perl semantic closures are callbacks.
They are called as nodes in a parse tree are evaluated.

Each Perl semantic closure is called with one or more arguments.
The first argument to a value action is always a per-parse-tree
object, which the callbacks can use as a scratchpad.
In this example, the per-parse-tree object is not used.

For a non-empty rule,
the second and any subsequent arguments to the callback are
the values,
in lexical order,
of the symbols on the right hand side of
the rule.
If the action is for an empty rule,
the per-parse-tree object will be its only argument.

Every value action is expected to return a value.
With one exception,
this value is passed up to a parent node
as an argument.
The exception is the value for the start rule.
The return value for the start rule becomes
the parse result.

Finally, C<actions_object> requires the package it specifies to
be a class, in the sense that it must have a C<new> constructor.
The value returned by the C<new> constructor is the per-parse-tree
object which, as mentioned, is not used in this example.
Here is our definition of C<My_Nodes::new>:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    sub My_Nodes::new { return {}; }

=for Marpa::R2::Display::End

=head1 Errors and exceptions

Methods in the Marpa API usually do not return errors.
When there are errors,
Marpa API methods throw an exception.

=head1 Inheritance

Classes in Marpa's API's are not designed to
be inherited.

=head1 The Marpa:: namespace

The C<Marpa::> top-level namespace is reserved.
For extensions to Marpa,
one appropriate place is the C<MarpaX::> namespace.
This practice helps avoid namespace collisions,
and follows a CPAN standard, as exemplified by
the
C<DBIx::>
C<LWPx::>
and
C<MooseX::>
which are for extensions of, respectively,
DBI, LWP and Moose.

=head1 Other documents

This document gives a semi-tutorial overview of Marpa's Scanless interface (SLIF).
For more details about the SLIF,
there is an
L<overview|Marpa::R2::Scanless>,
and pages describing
L<its DSL|Marpa::R2::Scanless::DSL>,
L<its grammar methods|Marpa::R2::Scanless:G>,
and
L<its recognizer methods|Marpa::R2::Scanless:R>.

Marpa has two other interfaces which may be of interest.
An older, more traditional, interface
is the
L<named argument inteface (NAIF)|Marpa::R2::NAIF>.
The NAIF is a middle level interface which uses Perl calls
instead of a DSL.
The NAIF is more low level than the SLIF.

There is also the L<the thin
interface|<Marpa::R2::Advanced::Thin>,
which provides direct access to the underlying
Libmarpa C library.
Of the Perl interfaces to Marpa,
the thin interface is the most low-level.
The thin interface offers efficient access to the full power of the
Marpa parse engine,
but it requires the application to do a lot of the work itself.

L<Marpa::R2::Vocabulary> is intended as a quick refresher in
parsing terminology,
emphasizing how the standard terms are used
in the Marpa context.
Marpa's standard semantics are fully described in the
L<Marpa::R2::Semantics> document.
Techniques for tracing and for debugging your Marpa grammars
are described in the
L<Marpa::R2::Tracing> document and the
L<Marpa::R2::Progress> document.
For those with a theoretical bent,
my sources, and other useful references, are described in
L<Marpa::R2::Advanced::Bibliography>.

=head1 Author

Jeffrey Kegler

=head2 Why is it called "Marpa"?

Marpa is the name of the greatest of the Tibetan "translators".
In his time (the 11th century AD) Indian Buddhism was
at its height.
Marpa's generation of scholars was devoted
to producing Tibetan versions of Buddhism's Sanskrit scriptures.
Marpa became the greatest of them,
and today is known as Marpa Lotsawa: "Marpa the Translator".

=head2 Blatant plug

Marpa is a character in my novel, B<The God Proof>.
B<The God
Proof> centers around Kurt GE<ouml>del's proof of God's existence.
Yes, I<that> Kurt GE<ouml>del, and yes, he really did work out a
God Proof (it's in his I<Collected Works>, Vol. 3, pp. 403-404).
B<The God Proof> is available
as a free download (L<http://www.lulu.com/content/933192>).
It can be purchased in print form at Amazon.com:
L<http://www.amazon.com/God-Proof-Jeffrey-Kegler/dp/1434807355>.

=head1 Support

L<Marpa::R2> comes without warranty.
Support is provided
on a volunteer basis
through the standard mechanisms for CPAN modules.
L<The Support document|Marpa::R2::Support> has details.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:

